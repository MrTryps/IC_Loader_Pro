Hello Gemini. I need your help with a C# ArcGIS Pro Add-in project.

### YOUR TASK
Your role is to act as an expert C# developer with a specialization in the ArcGIS Pro SDK. You will help me debug, refactor, and add new features to my existing solution. Please review all the context provided below before answering my specific question at the end.

### PROJECT OVERVIEW
The project is an ArcGIS Pro Add-in named "IC_Loader_Pro". Its primary purpose is to automate the processing of GIS data submissions that arrive via email. It involves reading emails from Outlook, validating attachments, processing GIS data (shapefiles, DWGs), and allowing a user to review and save the data to a geodatabase.

The main project's code is located on GitHub. You can review the `master` branch here for context on the main add-in's structure:
[https://github.com/mrtryps/ic_loader_pro/tree/master](https://github.com/mrtryps/ic_loader_pro/tree/master)

The solution also depends on several external class library projects. I have pasted the full content of the most important classes from those projects below.

---

### EXTERNAL DEPENDENCY: BIS_Tools_2025_C_Core Project
This project contains core, reusable tools for logging, database access, and file operations.

	#### FILE: BIS_DB_Tools.cs
	using BIS_Tools_DataModels_2025;
	using Oracle.ManagedDataAccess.Client; // For Oracle
	using System;
	using System.Collections.Concurrent;
	using System.Collections.Generic;
	using System.Data;
	using System.Data.Odbc;      // For PostgreSQL via ODBC
	using System.Data.OleDb;     // For Access
	using System.IO;
	using System.Linq;
	using System.Reflection;

	/// <summary>
	/// Abstract base class for all database tool interactions.
	/// Handles the lazy loading and caching of all named SQL queries from XML files.
	/// </summary>
	public abstract class BIS_DB_Tools
	{
		protected readonly BIS_Log _log;
		protected string _reportingClassName { get; set; } = "BIS_DB_Tools";
		private readonly string _connectionString;

		private static readonly ConcurrentDictionary<string, NamedQuerySettings> _queryCache =
			new ConcurrentDictionary<string, NamedQuerySettings>(StringComparer.OrdinalIgnoreCase);

		private static readonly Lazy<bool> _isLazyLoadComplete = new Lazy<bool>(() =>
		{
			var tempLog = new BIS_Log("DB_Tools_Static_Loader");
			return LoadAllNamedQueriesFromXml(tempLog);
		});

		public struct NamedQuerySettings
		{
			public string DataSourceType;
			public string Path;
			public string Sql;
			public string ProcedureName;
			public string Returns;
			public string ReturnParamName;
		}

		protected BIS_DB_Tools(BIS_Log errLog)
		{
			_log = errLog ?? throw new ArgumentNullException(nameof(errLog));
			if (!_isLazyLoadComplete.Value)
			{
				throw new InvalidOperationException("Failed to load critical named query settings from XML files. The application cannot start.");
			}
		}

		private static bool LoadAllNamedQueriesFromXml(BIS_Log log)
		{
			try
			{
				const string xmlDirectoryPath = @"\\dep-tcshared\shared\srp\SRP GISDATA\";
				var filesToLoad = new[] { "sql_rules.xml", "post_gre_sql_rules.xml" };

				foreach (var fileName in filesToLoad)
				{
					string fullPath = Path.Combine(xmlDirectoryPath, fileName);
					if (!File.Exists(fullPath))
					{
						log.RecordMessage($"Warning: Query file not found, skipping: {fullPath}", BIS_Log.BisLogMessageType.Warning);
						continue;
					}

					var dataSet = new DataSet();
					dataSet.ReadXml(fullPath);

					string tableName = dataSet.Tables.Count > 0 ? dataSet.Tables[0].TableName : string.Empty;
					if (string.IsNullOrEmpty(tableName) || !dataSet.Tables.Contains(tableName))
					{
						log.RecordMessage($"No data table found in query file: {fileName}", BIS_Log.BisLogMessageType.Warning);
						continue;
					}

					DataTable dt = dataSet.Tables[tableName];
					foreach (DataRow dr in dt.Rows)
					{
						string queryName = dr["QueryName"]?.ToString() ?? string.Empty;
						if (string.IsNullOrWhiteSpace(queryName)) continue;

						var settings = new NamedQuerySettings
						{
							DataSourceType = dr.Table.Columns.Contains("DataSourceType") ? dr["DataSourceType"]?.ToString() ?? string.Empty : string.Empty,
							Sql = dr.Table.Columns.Contains("SqlString") ? dr["SqlString"]?.ToString() ?? string.Empty : string.Empty,
							Path = dr.Table.Columns.Contains("DataSourcePath") ? dr["DataSourcePath"]?.ToString() ?? string.Empty : string.Empty,
							ProcedureName = dr.Table.Columns.Contains("ProcedureName") ? dr["ProcedureName"]?.ToString() ?? string.Empty : string.Empty,
							Returns = dr.Table.Columns.Contains("Returns") ? dr["Returns"]?.ToString() ?? string.Empty : string.Empty,
							ReturnParamName = dr.Table.Columns.Contains("ReturnParamName") ? dr["ReturnParamName"]?.ToString() ?? string.Empty : string.Empty
						};

						_queryCache.AddOrUpdate(queryName, settings, (key, oldSettings) => settings);
					}
				}
			  //  log.RecordMessage($"Successfully loaded a total of {_queryCache.Count} named queries into the cache.", BIS_Log.BisLogMessageType.Note);
				return true;
			}
			catch (Exception ex)
			{
				log.RecordError("A fatal error occurred while loading named query settings from XML.", ex, "LoadAllNamedQueriesFromXml");
				return false;
			}
		}

		protected NamedQuerySettings GetNamedQuery(string queryName)
		{
			if (!_queryCache.TryGetValue(queryName, out NamedQuerySettings settings))
			{
				throw new KeyNotFoundException($"No query found with the name ({queryName})");
			}
			return settings;
		}
	}

	// --- DATABASE-SPECIFIC CLASSES ---

	public class BisDbAccess : BIS_DB_Tools
	{
		public BisDbAccess(BIS_Log errLog) : base(errLog) { _reportingClassName = "BisDbAccess"; }

		public object ExecuteNamedQuery(string queryName, Dictionary<string, string> parameters = null)
		{
			NamedQuerySettings nq = GetNamedQuery(queryName);
			if (!nq.DataSourceType.Equals("Access", StringComparison.OrdinalIgnoreCase))
				throw new InvalidOperationException($"Query '{queryName}' is not an Access query.");

			string finalSql = nq.Sql;
			if (parameters != null)
			{
				foreach (var p in parameters) { finalSql = finalSql.Replace(p.Key, p.Value); }
			}

			return ExecuteRawQuery(finalSql, nq.Path, nq.Returns);
		}

		public object ExecuteRawQuery(string sql, string dbPath, string returnType = "RECORDSET")
		{
			if (string.IsNullOrEmpty(dbPath)) throw new InvalidOperationException("Database path must be provided for raw Access query.");
			string connectionString = $"Provider=Microsoft.ACE.OLEDB.12.0;Data Source={dbPath};";

			try
			{
				using (var conn = new OleDbConnection(connectionString))
				{
					conn.Open();
					using (var cmd = new OleDbCommand(sql, conn))
					{
						switch (returnType.ToUpperInvariant())
						{
							case "SCALAR": return cmd.ExecuteScalar();
							case "RECORDSET":
								var dt = new DataTable();
								using (var adapter = new OleDbDataAdapter(cmd)) { adapter.Fill(dt); }
								return dt;
							case "NOTHING": cmd.ExecuteNonQuery(); return null;
							default: throw new InvalidOperationException($"Unknown return type '{returnType}'.");
						}
					}
				}
			}
			catch (Exception ex) { _log.RecordError($"Error executing raw Access query on path '{dbPath}'. SQL: {sql}", ex, "ExecuteRawQuery"); throw; }
		}
	}

	public class BisDbCompass : BIS_DB_Tools
	{
		private readonly string _connectionString;
		public BisDbCompass(BIS_Log errLog, bool asDev = false, string userName = "your_user", string password = "your_password") : base(errLog)
		{
			_reportingClassName = "BisDbCompass";
			Environment.SetEnvironmentVariable("TNS_ADMIN", @"\\dep-tcshared\shared\srp\SRP GISDATA\Current Production Code\64_Bit");
			string dataSource = asDev ? "COMPASSDEV" : "(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=dep-zion.dep.state.nj.us)(PORT=1521))(ADDRESS=(PROTOCOL=TCP)(HOST=dep-bryce.dep.state.nj.us)(PORT=1521)))(CONNECT_DATA=(SERVICE_NAME=CMP_PRIMARY)))";
			_connectionString = $"User Id={userName};Password={password};Data Source={dataSource};";
		}

		public object ExecuteNamedQuery(string queryName, Dictionary<string, object> parameters = null)
		{
			NamedQuerySettings nq = GetNamedQuery(queryName);
			if (!nq.DataSourceType.Equals("COMPASS", StringComparison.OrdinalIgnoreCase))
				throw new InvalidOperationException($"Query '{queryName}' is not a COMPASS query.");
			return ExecuteRawQuery(nq.Sql, parameters, nq.Returns);
		}

		public object ExecuteRawQuery(string sql, Dictionary<string, object> parameters = null, string returnType = "RECORDSET")
		{
			parameters ??= new Dictionary<string, object>();
			try
			{
				using (var conn = new OracleConnection(_connectionString))
				{
					conn.Open();
					using (var cmd = new OracleCommand(sql, conn))
					{
						cmd.BindByName = true;
						foreach (var p in parameters) { cmd.Parameters.Add(new OracleParameter(p.Key, p.Value ?? DBNull.Value)); }
						switch (returnType.ToUpperInvariant())
						{
							case "SCALAR": return cmd.ExecuteScalar();
							case "RECORDSET":
								var dt = new DataTable();
								using (var adapter = new OracleDataAdapter(cmd)) { adapter.Fill(dt); }
								return dt;
							case "NOTHING": cmd.ExecuteNonQuery(); return null;
							default: throw new InvalidOperationException($"Unknown return type '{returnType}'.");
						}
					}
				}
			}
			catch (Exception ex) { _log.RecordError($"Error executing raw Compass query. SQL: {sql}", ex, "ExecuteRawQuery"); throw; }
		}
	}

	public class BisDbNjems : BIS_DB_Tools
	{
		private readonly string _connectionString;
		public BisDbNjems(BIS_Log errLog, string userName = "infomaker", string password = "infomaker") : base(errLog)
		{
			_reportingClassName = "BisDbNjems";
			Environment.SetEnvironmentVariable("TNS_ADMIN", @"\\dep-tcshared\shared\srp\SRP GISDATA\Current Production Code\64_Bit");
			_connectionString = $"Data Source=NJEMS;User Id={userName};Password={password};";
		}

		public object ExecuteNamedQuery(string queryName, Dictionary<string, object> parameters = null)
		{
			NamedQuerySettings nq = GetNamedQuery(queryName);
			if (!nq.DataSourceType.Equals("NJEMS", StringComparison.OrdinalIgnoreCase))
				throw new InvalidOperationException($"Query '{queryName}' is not an NJEMS query.");
			return ExecuteRawQuery(nq.Sql, parameters, nq.Returns);
		}

		public object ExecuteRawQuery(string sql, Dictionary<string, object> parameters = null, string returnType = "RECORDSET")
		{
			parameters ??= new Dictionary<string, object>();
			try
			{
				using (var conn = new OracleConnection(_connectionString))
				{
					conn.Open();
					using (var cmd = new OracleCommand(sql, conn))
					{
						cmd.BindByName = true;
						foreach (var p in parameters) { cmd.Parameters.Add(new OracleParameter(p.Key, p.Value.ToString ())); }
						switch (returnType.ToUpperInvariant())
						{
							case "SCALAR": return cmd.ExecuteScalar();
							case "RECORDSET":
								var dt = new DataTable();
								using (var adapter = new OracleDataAdapter(cmd)) { adapter.Fill(dt); }
								return dt;
							case "NOTHING": cmd.ExecuteNonQuery(); return null;
							default: throw new InvalidOperationException($"Unknown return type '{returnType}'.");
						}
					}
				}
			}
			catch (Exception ex) { _log.RecordError($"Error executing raw NJEMS query. SQL: {sql}", ex, "ExecuteRawQuery"); throw; }
		}
	}


	public class BIS_DB_PostGre : BIS_DB_Tools
	{
		private readonly string _connectionString;

		private BIS_DB_PostGre(BIS_Log errLog, WorkSpaceRule wsRule) : base(errLog)
		{
			_reportingClassName = "BIS_DB_PostGre";
			_connectionString = $"Driver={{PostgreSQL Unicode}};Database={wsRule.Database};Server={wsRule.Server};Port={wsRule.Port};Uid={wsRule.User};Pwd={wsRule.Password};";
		}


		public BIS_DB_PostGre(BIS_Log errLog, string userName = "mmoore", string password = "Mi71moor") : base(errLog)
		{
			_reportingClassName = "BIS_DB_PostGre";
			_connectionString = $"Driver={{PostgreSQL Unicode}};Database=srp;Server=dep-v-agis4;Port=5433;Uid={userName};Pwd={password};";
		}

		// This is the primary method for executing queries defined in your XML rules.
		public object ExecuteNamedQuery(string queryName, Dictionary<string, object> parameters = null)
		{
			parameters ??= new Dictionary<string, object>();
			NamedQuerySettings nq = GetNamedQuery(queryName);

			if (!nq.DataSourceType.ToUpper().StartsWith("POSTGRE"))
			{
				throw new InvalidOperationException($"Query '{queryName}' is not a PostgreSQL query.");
			}

			try
			{
				using (var conn = new OdbcConnection(_connectionString))
				{
					conn.Open();
					using (var cmd = conn.CreateCommand())
					{
						switch (nq.DataSourceType.ToUpperInvariant())
						{
							case "POSTGREP": // For inline SQL
								cmd.CommandText = nq.Sql;
								AddParameters(cmd, parameters.Values.ToList());
								break;

							case "POSTGREP_PROCEDURE": // For a stored procedure
								string paramPlaceholders = string.Join(",", Enumerable.Repeat("?", parameters.Count));
								cmd.CommandText = $"{{CALL {nq.ProcedureName}({paramPlaceholders})}}";
								cmd.CommandType = CommandType.Text;
								AddParameters(cmd, parameters.Values.ToList());
								break;

							default:
								throw new InvalidOperationException($"Unsupported PostgreSQL DataSourceType: '{nq.DataSourceType}'");
						}

						return ExecuteCommand(cmd, nq.Returns);
					}
				}
			}
			catch (Exception ex)
			{
				_log.RecordError($"Error executing named query '{queryName}'.", ex, "ExecuteNamedQuery");
				throw;
			}
		}

		/// <summary>
		/// Creates a new instance of the BIS_DB_PostGre tool configured for a specific workspace rule.
		/// </summary>
		public static BIS_DB_PostGre CreateFromRule(WorkSpaceRule wsRule, BIS_Log log)
		{
			if (wsRule == null)
				if (log == null)
				{
					// We cannot operate without a logger.
					throw new ArgumentNullException(nameof(log), "A valid logger must be provided.");
				}

			if (wsRule == null)
			{
				log.RecordError("WorkSpaceRule cannot be null.", null, nameof(CreateFromRule));
				return null;
			}
			// Pass the provided logger to the private constructor.
			return new BIS_DB_PostGre(log, wsRule);
		}

		/// <summary>
		/// Executes a raw SQL query string directly against the database.
		/// </summary>
		/// <param name="sql">The SQL query string to execute.</param>
		/// <param name="parameters">An optional list of parameters for the query.</param>
		/// <param name="returnType">The expected return type (e.g., "RECORDSET", "SCALAR", "NOTHING").</param>
		/// <returns>The result of the query, which varies based on the returnType.</returns>
		public object ExecuteRawQuery(string sql, List<object> parameters = null, string returnType = "RECORDSET")
		{
			try
			{
				using (var conn = new OdbcConnection(_connectionString))
				{
					conn.Open();
					using (var cmd = new OdbcCommand(sql, conn))
					{
						AddParameters(cmd, parameters);
						return ExecuteCommand(cmd, returnType);
					}
				}
			}
			catch (Exception ex)
			{
				_log.RecordError($"Error executing raw PostGre query. SQL: {sql}", ex, "ExecuteRawQuery");
				throw;
			}
		}

		// This helper is kept for any legacy code that might pass a List instead of a Dictionary
		public object ExecuteNamedQuery(string queryName, List<object> parameters)
		{
			var paramDict = parameters?.ToDictionary(p => "param" + parameters.IndexOf(p));
			return ExecuteNamedQuery(queryName, paramDict);
		}

		// Private helper to add parameters to an OdbcCommand
		private void AddParameters(OdbcCommand cmd, List<object> parameters)
		{
			if (parameters == null) return;
			foreach (var p in parameters)
			{
				cmd.Parameters.AddWithValue(null, p ?? DBNull.Value);
			}
		}

		// Private helper to execute any command and handle the return type
		private object ExecuteCommand(OdbcCommand cmd, string returnType)
		{
			switch (returnType.ToUpperInvariant())
			{
				case "SCALAR":
					return cmd.ExecuteScalar();

				case "RECORDSET":
				case "CURSOR":
					var dt = new DataTable();
					using (var adapter = new OdbcDataAdapter(cmd))
					{
						adapter.Fill(dt);
					}
					return dt;

				case "NOTHING":
					cmd.ExecuteNonQuery();
					return null;

				default:
					throw new InvalidOperationException($"Unknown return type '{returnType}'.");
			}
		}
	}

	#### FILE: BIS_log.cs
	using Microsoft.VisualBasic;
	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	using System.Globalization;
	using System.IO;
	using System.Linq;
	using System.Net.NetworkInformation;
	using System.Text;
	using BIS_Tools_DataModels_2025;

	public class BIS_Log
	{
		public enum BisLogMessageType
		{
			Note,
			Warning,
			FatalError
		}

		private const string DefaultPath = @"\\dep-tcshared\shared\srp\SRP GISDATA\Logs_General";
		private bool _overwrite = false;
		private string _fileNameAndPath = "";
		private readonly List<BisError> _errors = new List<BisError>();
		private int _tabSpaces = 5; // Used as a flag in recordMessage, not for tab character width
		private bool _emailSent = false;
		private string _warningSeperatorCharacter = "-";
		private string _exceptionSeperatorCharacter = "#";
		private int _seperatorLength = 25;
		private bool _valid = true;
		private int _errorTabStep = 0;
		private string _initialCallingClass = "";
		private bool _logWritten = false;
		private bool _writingErrorReported = false;

		public bool Valid => _valid;
		public string FileNameAndPath => _fileNameAndPath;
		public bool EmailSent => _emailSent;
		public int ErrorCount => _errors.Count;

		public BisError? LastError
		{
			get
			{
				if (_errors.Count == 0) return null;
				return _errors.LastOrDefault(); // Using LastOrDefault for safety
			}
		}

		public bool Overwrite
		{
			get => _overwrite;
			set => _overwrite = value;
		}

		public string WarningSeperatorCharacter
		{
			get => _warningSeperatorCharacter;
			set => _warningSeperatorCharacter = value ?? "-"; // Ensure not null
		}

		public string ExceptionSeperatorCharacter
		{
			get => _exceptionSeperatorCharacter;
			set => _exceptionSeperatorCharacter = value ?? "#"; // Ensure not null
		}

		public int SeparatorLength // Corrected property name from 'seperatorLength'
		{
			get => _seperatorLength;
			set => _seperatorLength = Math.Max(0, value); // Ensure non-negative
		}

		public BIS_Log(string callingClassName, string logName = "", string logPath = "")
		{
			if (string.IsNullOrEmpty(callingClassName)) callingClassName = "*No Class Defined*";
			_initialCallingClass = callingClassName;

			if (string.IsNullOrEmpty(logPath)) logPath = DefaultPath;
			if (string.IsNullOrEmpty(logName)) logName = "Log_" + callingClassName;

			try
			{
				BuildFileNameAndPath(logName, logPath);
			}
			catch (Exception ex)
			{
				// reportClassError calls Exit Sub, which is 'return' here.
				// It also attempts to send an email.
				ReportClassError("Constructor_BuildFileNameAndPath", ex);
				_valid = false; // Ensure validity is false if construction fails significantly
				return;
			}
			// Original code had writeHeader commented out here. If needed, uncomment and adapt.
			// try
			// {
			//     WriteHeader();
			// }
			// catch (Exception ex)
			// {
			//     ReportClassError("Constructor_WriteHeader", ex);
			//     _valid = false;
			// }
		}

		public bool WriteText(string textToAdd)
		{
			if (!_valid) return false; // Don't write if log setup failed

			try
			{
				// Using statement ensures the StreamWriter is properly disposed.
				// The 'true' argument means append to file if it exists.
				using (var ts = new StreamWriter(_fileNameAndPath, true, Encoding.UTF8))
				{
					ts.WriteLine(textToAdd);
				}
				return true;
			}
			catch (Exception ex)
			{
				ReportClassError("WriteText", ex);
				return false;
			}
		}

		public void RecordError(string msg, Exception? exceptionToReport, string methodName)
		{
			if (!_valid) return;

			if (string.IsNullOrEmpty(msg)) msg = "*NoMessageReported*";
			if (string.IsNullOrEmpty(methodName)) methodName = "*MethodNotDefined*";

			exceptionToReport ??= new Exception("Exception not provided to RecordError, but an error was logged.");

			_errorTabStep = 0; // Reset error tab step for a new distinct error
			var err = new BisError
			{
				ErrorType = BisError.BisErrorType.Fatal, // Consistent with original
				Message = msg,
				ReportingClass = _initialCallingClass, // Or dynamically get current class if desired
				ReportingMethod = methodName,
				Exception = exceptionToReport
			};
			_errors.Add(err); // Store the structured error

			// Log the detailed error message. True for includeTimestamp.
			RecordMessage(err.ToString(), BisLogMessageType.FatalError, 0, true);
		}

		public void Add(string textToAdd)
		{
			RecordMessage(textToAdd, BisLogMessageType.Note);
		}

		public void AddBlankLine()
		{
			RecordMessage("", BisLogMessageType.Note);
		}

		public void LogErrorTreeBranch(string className, string methodName)
		{
			if (!_valid) return;

			if (string.IsNullOrEmpty(className)) className = "*ClassNotDefined*";
			if (string.IsNullOrEmpty(methodName)) methodName = "*MethodNotDefined*"; // Corrected from className to methodName

			if (!_logWritten)
			{
				try
				{
					WriteHeader();
				}
				catch (Exception ex)
				{
					if (!_writingErrorReported)
					{
						// Replaced MsgBox
						Console.WriteLine($"[BIS_Log Critical Error] Error creating the log: ({_fileNameAndPath})");
						Console.WriteLine("[BIS_Log Critical Error] Was attempting to log error tree branch.");
						// Consider logging this to a fallback mechanism if primary log fails
						ReportClassError("LogErrorTreeBranch_WriteHeader", ex); // Internal error reporting
						_writingErrorReported = true;
					}
					return; // Exit Sub
				}
			}

			_errorTabStep++;
			string indent = new string('*', _errorTabStep); // VB: New String("*", cErrorTabStep)
			WriteText($"{indent}Called From: {className}.{methodName}");
		}

		public void RecordMessage(string textToAdd, BisLogMessageType messageType, int tabLevel = 0, bool includeTimestamp = false)
		{
			if (!_valid) return;

			if (!NetworkInterface.GetIsNetworkAvailable())
			{
				// Original code calls ReportClassError which then calls Exit Sub.
				ReportClassError("RecordMessage_NetworkUnavailable", new Exception("The network is currently unavailable. Log message not written."));
				return; // Exit Sub
			}

			if (!_logWritten)
			{
				try
				{
					WriteHeader();
				}
				catch (Exception ex)
				{
					if (!_writingErrorReported)
					{
						// Replaced MsgBox
						Console.WriteLine($"[BIS_Log Critical Error] Error creating the log: ({_fileNameAndPath})");
						Console.WriteLine($"[BIS_Log Critical Error] Was attempting to record the message:{Environment.NewLine}{textToAdd}");
						ReportClassError("RecordMessage_WriteHeader", ex);
						_writingErrorReported = true;
					}
					return; // Exit Sub
				}
			}

			var textLines = new List<string>();
			string indent = new string(' ', Math.Max(0, tabLevel)); // Ensure tabLevel is not negative
			string timeStamp = "";

			try
			{
				// Original: If cTabSpaces > 0 Then textToAdd = Replace(textToAdd, vbCrLf, vbCrLf & indent)
				// This logic seems to be about maintaining indentation for multi-line messages.
				// _tabSpaces is initialized to 5 but its value isn't directly used to form `indent`.
				if (_tabSpaces > 0 && textToAdd != null)
				{
					textToAdd = textToAdd.Replace(Environment.NewLine, Environment.NewLine + indent);
				}

				if (includeTimestamp)
				{
					timeStamp = indent + DateTime.Now.ToString("yyyy-MM-dd--HH-mm-ss");
				}

				switch (messageType)
				{
					case BisLogMessageType.Note:
						if (!string.IsNullOrEmpty(timeStamp)) textLines.Add(timeStamp);
						textLines.Add(indent + textToAdd);
						break;
					case BisLogMessageType.Warning:
						textLines.Add(""); // Blank line before
						textLines.Add(indent + "WARNING " + new string(_warningSeperatorCharacter.FirstOrDefault(), _seperatorLength));
						if (!string.IsNullOrEmpty(timeStamp)) textLines.Add(timeStamp);
						textLines.Add(indent + textToAdd);
						textLines.Add(indent + "WARNING " + new string(_warningSeperatorCharacter.FirstOrDefault(), _seperatorLength));
						textLines.Add(""); // Blank line after
						break;
					case BisLogMessageType.FatalError:
						textLines.Add("");
						textLines.Add(indent + "ERROR " + new string(_exceptionSeperatorCharacter.FirstOrDefault(), _seperatorLength));
						if (!string.IsNullOrEmpty(timeStamp)) textLines.Add(timeStamp);
						textLines.Add(indent + textToAdd);
						textLines.Add(indent + "ERROR " + new string(_exceptionSeperatorCharacter.FirstOrDefault(), _seperatorLength));
						textLines.Add("");
						break;
					default: // Treat as note
						if (!string.IsNullOrEmpty(timeStamp)) textLines.Add(timeStamp);
						textLines.Add(indent + textToAdd);
						break;
				}
				string messageToWrite = string.Join(Environment.NewLine, textLines);
				WriteText(messageToWrite);
			}
			catch (Exception ex)
			{
				ReportClassError("RecordMessage_FormatAndWrite", ex);
			}
		}

		/// <summary>
		/// Placeholder for a function that was intended to remove bad characters.
		/// Original implementation was missing.
		/// </summary>
		/// <param name="stringToCheck">The string to check (passed by reference in VB).</param>
		/// <returns>Currently always false. Needs implementation.</returns>
		private bool BadCharactersRemoved(ref string stringToCheck)
		{
			// TODO: Implement character sanitization logic if needed.
			// Original VB code: ' need to write this' and returned False.
			// Example: stringToCheck = Regex.Replace(stringToCheck, @"[^\w\.@-]", "");
			return false; // Placeholder, as per original
		}

		private void BuildFileNameAndPath(string logName, string logPath)
		{
			if (string.IsNullOrEmpty(logName)) throw new ArgumentException("Log name cannot be empty.", nameof(logName));
			if (string.IsNullOrEmpty(logPath)) throw new ArgumentException("Log path cannot be empty.", nameof(logPath));

			DateTime now = DateTime.Now;
			string curMonth = now.ToString("MMMM", CultureInfo.CurrentCulture); // VB: MonthName(Now().Month)
			int curYear = now.Year;
			string curUser = Environment.UserName;

			if (!string.IsNullOrEmpty(Path.GetExtension(logName)))
			{
				logName = Path.GetFileNameWithoutExtension(logName);
			}
			// Sanitize logName components before combining to prevent path traversal or invalid characters
			// curUser might contain domain, path.GetInvalidFileNameChars() can be used for sanitization
			// For simplicity here, direct concatenation is used as in original.
			logName = $"{logName}_{curUser}_{now:yyyy-MM-dd--HH-mm-ss}";
			logName = Path.ChangeExtension(logName, "txt");

			// Ensure the general root path exists
			if (!Directory.Exists(logPath))
			{
				Directory.CreateDirectory(logPath);
			}

			// Now the monthly sub directory
			string subRootPath = $"Logs_{curYear}_{curMonth}";
			logPath = Path.Combine(logPath, subRootPath);

			if (!Directory.Exists(logPath))
			{
				Directory.CreateDirectory(logPath);
			}

			_fileNameAndPath = Path.Combine(logPath, logName);
		}

		private BisError? LastMessage(BisError.BisErrorType errorType = BisError.BisErrorType.Fatal)
		{
			// Iterating in reverse to find the last matching error
			for (int lp = _errors.Count - 1; lp >= 0; lp--)
			{
				if (_errors[lp].ErrorType == errorType)
				{
					return _errors[lp];
				}
			}
			return null;
		}

		private void WriteHeader()
		{
			if (!_valid) return; // Don't write if log setup failed

			var headerLines = new List<string>
			{
				"LogDate: " + DateTime.Now.ToString("MM-dd-yyyy_hh:mm:ss"),
				"Machine: " + Environment.MachineName,
				"User: " + Environment.UserName,
				"Initial reporting class: " + _initialCallingClass,
				" " // Blank line
			};
			WriteText(string.Join(Environment.NewLine, headerLines));
			_logWritten = true;
		}

		private void ReportClassError(string location, Exception ex)
		{
			_valid = false; // Mark log as invalid due to internal error
			string errorMessage = $"An unhandled critical error occurred in the BIS_Log class itself at location: {location}.{Environment.NewLine}The following exception was being processed or generated this error:";

			// Log to console as a fallback since file logging might be compromised
			Console.WriteLine("--- BIS_LOG INTERNAL CRITICAL ERROR ---");
			Console.WriteLine(errorMessage);
			Console.WriteLine(ex.ToString());
			Console.WriteLine("--- END BIS_LOG INTERNAL CRITICAL ERROR ---");

			// Original code showed MsgBox, which is UI dependent.
			// MsgBox(errMsg & vbCrLf & ex.ToString)

			// Attempt to email the critical log error
			// Assuming Bis_EmailTools.GenericEmail.emailMessageType is available in the placeholder
			EmailLog(BisEmailTools.GenericEmail.EmailMessageType.Complete, $"Critical error in BIS_Log at {location}.", true);

			// Original VB code had 'Exit Sub' here. In C#, this means the current method execution stops.
			// This is implicitly handled by reaching the end of the void method or using 'return;'.
			// If this method is called from a constructor or a critical path,
			// the caller needs to handle the '_valid == false' state.
		}

		public bool EmailLog(BisEmailTools.GenericEmail.EmailMessageType messageType, string textToAdd = "", bool forceMultipleSends = false)
		{
			if (!_valid && messageType != BisEmailTools.GenericEmail.EmailMessageType.Complete) // Allow sending "Complete" even if log is invalid due to internal error
			{
				Console.WriteLine("[BIS_Log] EmailLog called, but log is in an invalid state. Email not sent unless it's a final error report.");
				return false;
			}

			if (_emailSent && !forceMultipleSends)
			{
				RecordMessage("Email already sent. Ignoring multiple requests.", BisLogMessageType.Note);
				return true;
			}

			var et = new BisEmailTools.GenericEmail(); // Uses placeholder
			var bodyMsg = new StringBuilder();

			if (!string.IsNullOrEmpty(textToAdd))
			{
				bodyMsg.AppendLine(textToAdd);
				bodyMsg.AppendLine(); // Add blank line like original vbCrLf & vbCrLf
			}

			et.SubjectLine = "Error report for: " + (string.IsNullOrEmpty(_fileNameAndPath) ? "Log (path Not Set)" : _fileNameAndPath);

			try
			{
				switch (messageType)
				{
					case BisEmailTools.GenericEmail.EmailMessageType.LogPath:
						et.AddTextToBody(bodyMsg.ToString());
						et.AddTextToBody(Environment.NewLine + "Log: " + _fileNameAndPath);
						break;
					case BisEmailTools.GenericEmail.EmailMessageType.LastError:
						et.AddTextToBody(bodyMsg.ToString());
						var lastMsg = LastMessage(); // Gets last fatal error by default
						et.AddTextToBody(lastMsg?.ToString() ?? "No fatal error found to report.");
						break;
					case BisEmailTools.GenericEmail.EmailMessageType.Complete:
						et.AddTextToBody(bodyMsg.ToString());
						et.AddTextToBody(ErrorsReportedAsString());
						et.AddTextToBody(Environment.NewLine + "Log: " + _fileNameAndPath);
						break;
				}
				et.SendEmail(); // Placeholder sends to Console
				_emailSent = true; // Mark as sent only if successful (actual implementation might throw)
				return true; // Assuming send was successful in placeholder
			}
			catch (Exception ex)
			{
				// If emailing itself fails, we report this as a class error.
				// This could lead to recursion if ReportClassError also tries to email and fails.
				// Add a guard or different handling for meta-errors.
				Console.WriteLine($"[BIS_Log Critical Error] Failed to send email log. Location: EmailLog. Exception: {ex.Message}");
				// ReportClassError("EmailLog_SendFailure", ex); // Avoid potential recursion
				return false;
			}
			// Original VB had 'et = Nothing' in Finally, not needed in C# for managed objects without IDisposable if 'et' is local.
		}

		private string ErrorsReportedAsString()
		{
			if (_errors.Count == 0) return "No errors recorded.";

			var errStrings = new List<string>();
			foreach (BisError b in _errors)
			{
				errStrings.Add(b.ToString());
			}
			return string.Join(Environment.NewLine + "--------------------" + Environment.NewLine, errStrings);
		}

		public void Open()
		{
			if (!_valid || string.IsNullOrEmpty(_fileNameAndPath) || !File.Exists(_fileNameAndPath))
			{
				Console.WriteLine($"[BIS_Log] Cannot open log file. Valid: {_valid}, path: '{_fileNameAndPath}', Exists: {(!string.IsNullOrEmpty(_fileNameAndPath) && File.Exists(_fileNameAndPath))}");
				// Original code didn't have checks, but it's good practice.
				return;
			}

			try
			{
				var p = new Process();
				p.StartInfo = new ProcessStartInfo("notepad.exe", $"\"{_fileNameAndPath}\"") // Enclose path in quotes
				{
					UseShellExecute = true // Recommended for opening files with default app
				};
				p.Start();
			}
			catch (Exception ex)
			{
				Console.WriteLine($"[BIS_Log] Error opening log file '{_fileNameAndPath}' with notepad. Exception: {ex.Message}");
				// reportClassError("OpenLogFile", ex); // Could be too noisy for a simple open failure.
			}
		}
	}
	
	#### FILE: Bis_Regex.cs
	using System;
	using System.Collections.Concurrent;
	using System.Collections.Generic;
	using System.Data;
	using System.IO;
	using System.Linq;
	using System.Text.RegularExpressions;

	public class Bis_Regex
	{
		private readonly BIS_Log _log;
		private readonly string _reportingClassName = "BisRegex";

		// The cache for our rules. A ConcurrentDictionary is thread-safe.
		private readonly ConcurrentDictionary<string, RegexRule> _ruleCache;

		// The DataTable is now loaded lazily and only once.
		private readonly Lazy<DataTable> _lazyRegexDataTable;

		public struct RegexRule
		{
			public string RuleName;
			public string SearchPattern;
			public string ReplacePattern;
			public bool CaseSensitive;
			public string Note;
		}

		public Bis_Regex(BIS_Log errorLog)
		{
			_log = errorLog ?? throw new ArgumentNullException(nameof(errorLog));
			_ruleCache = new ConcurrentDictionary<string, RegexRule>(StringComparer.OrdinalIgnoreCase);

			// Initialize the Lazy<T> object. The code inside this lambda will only run
			// the first time _lazyRegexDataTable.Value is accessed.
			_lazyRegexDataTable = new Lazy<DataTable>(() =>
			{
				const string xmlPath = @"\\dep-tcshared\shared\srp\SRP GISDATA\";
				string xmlSchemaName = Path.Combine(xmlPath, "regex_rules_sh.xml");
				string xmlFileName = Path.Combine(xmlPath, "regex_rules.xml");

				var dt = new DataTable() { CaseSensitive = false };

				try
				{
					if (File.Exists(xmlSchemaName))
					{
						dt.ReadXmlSchema(xmlSchemaName);
					}
					if (File.Exists(xmlFileName))
					{
						dt.ReadXml(xmlFileName);
					}
					else
					{
						_log.RecordMessage($"Regex data file not found: '{xmlFileName}'. No rules will be available.", BIS_Log.BisLogMessageType.FatalError);
					}
				}
				catch (Exception ex)
				{
					_log.RecordError($"Fatal error loading Regex patterns from XML. path: '{xmlFileName}'.", ex, "Bis_Regex.LazyLoad");
					// Return an empty DataTable on failure so the application doesn't crash.
					return new DataTable("RegexRules");
				}
				return dt;
			});
		}

		/// <summary>
		/// Gets a specific regex rule. It uses a cache to avoid repeated lookups.
		/// </summary>
		public RegexRule ReturnRegexRule(string ruleName)
		{
			if (string.IsNullOrWhiteSpace(ruleName))
			{
				throw new ArgumentException("Regex rule name cannot be empty.", nameof(ruleName));
			}

			// 1. Check the cache first.
			if (_ruleCache.TryGetValue(ruleName, out RegexRule cachedRule))
			{
				return cachedRule;
			}

			// 2. If not in cache, load from the DataTable (this triggers the lazy load if it's the first time).
			DataRow dr = FindDataRowForRule(ruleName);
			if (dr == null)
			{
				throw new KeyNotFoundException($"Regex rule '{ruleName}' not found.");
			}

			// 3. Parse the DataRow into a rule object.
			var newRule = new RegexRule
			{
				RuleName = dr.IsNull("expressionname") ? string.Empty : dr["expressionname"].ToString(),
				SearchPattern = dr.IsNull("pattern") ? string.Empty : dr["pattern"].ToString(),
				ReplacePattern = dr.IsNull("replacepattern") ? string.Empty : dr["replacepattern"].ToString(),
				Note = dr.IsNull("note") ? string.Empty : dr["note"].ToString(),
				CaseSensitive = !dr.IsNull("case_sensitive") && Convert.ToBoolean(dr["case_sensitive"])
			};

			// 4. Add the new rule to the cache for next time.
			_ruleCache.TryAdd(ruleName, newRule);

			return newRule;
		}

		// Helper method to find a row in the lazily-loaded DataTable
		private DataRow FindDataRowForRule(string expressionName)
		{
			// Accessing .Value here is what triggers the file read on the first call.
			var dataTable = _lazyRegexDataTable.Value;

			string safeExpressionName = expressionName.Replace("'", "''");
			string filter = $"expressionname = '{safeExpressionName}'";
			DataRow[] dataRows = dataTable.Select(filter);

			if (dataRows.Length == 0) return null;
			if (dataRows.Length > 1)
			{
				_log.RecordError($"Duplicate regex rule name '{expressionName}' found.", null, "FindDataRowForRule");
			}
			return dataRows[0];
		}

		/// <summary>
		/// Checks if a string matches a literal regex pattern.
		/// </summary>
		public bool StringMatchesPattern(string pattern, string stringToTest, bool caseSensitive = false)
		{
			if (string.IsNullOrEmpty(pattern) || stringToTest == null) return false;
			try
			{
				RegexOptions options = caseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
				return Regex.IsMatch(stringToTest, pattern, options);
			}
			catch (ArgumentException argEx)
			{
				_log.RecordError($"Invalid regex pattern provided: '{pattern}'.", argEx, "StringMatchesPattern");
				throw; // Re-throw to indicate a bad pattern was provided
			}
		}


		// Public methods now use the new ReturnRegexRule method
		public bool StringMatchesNamedRegex(string regexName, string stringToTest)
		{
			try
			{
				RegexRule rule = ReturnRegexRule(regexName);
				if (string.IsNullOrEmpty(rule.SearchPattern) || stringToTest == null) return false;

				RegexOptions options = rule.CaseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
				return Regex.IsMatch(stringToTest, rule.SearchPattern, options);
			}
			catch (Exception ex)
			{
				_log.RecordError($"Error in StringMatchesNamedRegex for rule '{regexName}'.", ex, "StringMatchesNamedRegex");
				return false; // Return false on error to prevent crashes
			}
		}

		public List<string> ReturnMatchesOfNamedRegex(string regexName, string stringToSearch)
		{
			var matches = new List<string>();
			try
			{
				RegexRule rule = ReturnRegexRule(regexName);
				if (string.IsNullOrEmpty(rule.SearchPattern) || stringToSearch == null) return matches;

				RegexOptions options = rule.CaseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
				MatchCollection matchCollection = Regex.Matches(stringToSearch, rule.SearchPattern, options);
				foreach (Match match in matchCollection)
				{
					matches.Add(match.Value);
				}
			}
			catch (Exception ex)
			{
				_log.RecordError($"Error in ReturnMatchesOfNamedRegex for rule '{regexName}'.", ex, "ReturnMatchesOfNamedRegex");
			}
			return matches;
		}

		/// <summary>
		/// Returns all matches for a literal regex pattern from a string.
		/// </summary>
		public List<string> ReturnMatchesPattern(string pattern, string stringToSearch, bool caseSensitive = false)
		{
			var matches = new List<string>();
			if (string.IsNullOrEmpty(pattern) || stringToSearch == null) return matches;
			try
			{
				RegexOptions options = caseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
				MatchCollection matchCollection = Regex.Matches(stringToSearch, pattern, options);
				foreach (Match match in matchCollection)
				{
					matches.Add(match.Value);
				}
			}
			catch (ArgumentException argEx)
			{
				_log.RecordError($"Invalid regex pattern provided: '{pattern}'.", argEx, "ReturnMatchesPattern");
				throw;
			}
			return matches;
		}

		public string ReplaceUsingNamedExpression(string stringToUpdate, string regexName, string customReplacementPattern = null)
		{
			if (stringToUpdate == null) return string.Empty;
			try
			{
				RegexRule rule = ReturnRegexRule(regexName);
				if (string.IsNullOrEmpty(rule.SearchPattern)) return stringToUpdate;

				string replacement = customReplacementPattern ?? rule.ReplacePattern ?? string.Empty;
				RegexOptions options = rule.CaseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
				return Regex.Replace(stringToUpdate, rule.SearchPattern, replacement, options);
			}
			catch (Exception ex)
			{
				_log.RecordError($"Error in ReplaceUsingNamedExpression for rule '{regexName}'.", ex, "ReplaceUsingNamedExpression");
				return stringToUpdate; // Return original string on error
			}
		}
	}
	
### EXTERNAL DEPENDENCY: BIS_Tools_DataModels_2025 Project
This project contains the data structures used throughout the solution.

	#### FILE: IcGisTypeSetting.cs
	namespace BIS_Tools_DataModels_2025
{
    public class IcGisTypeSetting
    {
        public string IcType { get; set; }
        public string AsSubmittedPath { get; set; }
        public bool LoadEmails { get; set; }
        public bool TestSet { get; set; }
        public string IdPrefix { get; set; } // VB: Id_Prefix
        public int EmailTypeValue { get; set; } // VB: Integer
        public OutlookFolderSet EmailFolderSet { get; set; } = new OutlookFolderSet();
        public string OutlookInboxFolderPath { get; set; }
        public string OutlookProcessedFolderPath { get; set; }
        public string OutlookSpamFolderPath { get; set; }
        public string OutlookCorrespondenceFolderPath { get; set; }
        public List<AcceptedDatasetType> AcceptedDatasets { get; set; }
        public Dictionary<string, List<string>> FeatureNameFilters { get; set; }
        public List<IcFeatureField> FeatureFields { get; set; }
        public GeometryRules GeometryRules { get; set; } = new GeometryRules();
        public FeatureclassRule ProposedFeatureClass { get; set; } = new FeatureclassRule();
        public FeatureclassRule ShapeInfoTable { get; set; } = new FeatureclassRule(); // VB: shape_info_table
        public FeatureclassRule FinalFeatureClass { get; set; } = new FeatureclassRule();
        public string ContaminantsQueryName { get; set; }
        public string TasksQueryName { get; set; }
        public string NjemsBackgroundQueryName { get; set; }
        public string GeologyQueryName { get; set; }
        public string ParcelQueryName { get; set; }
        public string CtnQueryName { get; set; }
        public string SiteIdQueryName { get; set; }
        public string IntDocIdQueryName { get; set; } // VB: int_doc_id_QueryName
        public string IdsOfActiveIcsQueryName { get; set; } // VB: ids_of_active_ics_QueryName
        public string NjemsSubjectItemQueryName { get; set; } // VB: njems_subject_item_queryName
        public string DocumentsQueryName { get; set; } // VB: documents_query_name
        public string HistoricFillQueryName { get; set; }
        public List<IcFieldUpdateRule> FieldUpdateRules { get; set; }
        public string SubjectItemCategoryCode { get; set; }
        public string ProposedLayerPath { get; set; }
        public bool AutoMergeWithExistingRecentPolygons { get; set; }
        public string TestSenderEmail { get; set; }

        public IcGisTypeSetting()
        {
            AcceptedDatasets = new List<AcceptedDatasetType>();
            FeatureNameFilters = new Dictionary<string, List<string>>();
            FeatureFields = new List<IcFeatureField>();
            FieldUpdateRules = new List<IcFieldUpdateRule>();
            EmailFolderSet = new OutlookFolderSet();
            GeometryRules = new GeometryRules();
            ProposedFeatureClass = new FeatureclassRule();
            ShapeInfoTable = new FeatureclassRule();
            FinalFeatureClass = new FeatureclassRule();
        }
    }
}

#FILE Enums.cs
namespace BIS_Tools_DataModels_2025
{
    public enum WhenToTransferToNJEMS
    {
        Never = 0,
        Always = 1,
        WhenEmpty = 2
    }

    public enum TestActionResponse
    {
        Fail = 7,
        IncompleteTest = 6,
        Manual = 5,
        Warn = 4,
        Note = 3,
        Skip = 2,
        Pass = 1,
        None = 0
    }
}

####FILE: FeatureclassRule.cs
namespace BIS_Tools_DataModels_2025
{
    public class FeatureclassRule
    {
        public string FeatureClassName { get; set; }
        public string PostGreFeatureClassName { get; set; }
        public WorkSpaceRule WorkSpaceRule { get; set; } = new WorkSpaceRule();
        public string DefaultLayerTemplate { get; set; }
    }
}

##FILE: WorkSpaceRule.cs
namespace BIS_Tools_DataModels_2025
{
    public class WorkSpaceRule
    {
        public string WorkspaceName { get; set; }
        public string Server { get; set; }
        public string Instance { get; set; }
        public string Version { get; set; }
        public string User { get; set; }
        public string Database { get; set; }
        public string Password { get; set; }
        public string WorkspaceType { get; set; }
        public string ConnectionName { get; set; }
        public int Port { get; set; }
    }
}

####FILE: fileset.cs
namespace BIS_Tools_DataModels_2025
{
    public class fileset
    {
        public string fileName { get; set; }
        public string path { get; set; }
        public List<string> extensions { get; set; } = new List<string>();
        public string filesetType { get; set; }
        public bool validSet { get; set; }
        public string originalFileName { get; set; }
        public bool anyFilesFound { get; set; }
        public List<string> filesInSet { get; set; }
        public List<string> requiredExtensionsFound { get; set; }
        public List<string> optionalExtensionsFound { get; set; }
        public List<string> requiredExtensionsNotFound { get; set; }
        public bool validFileSet { get; set; }

        public fileset()
        {
            extensions = new List<string>();
        }
    }
}

###FILE: EmailType.cs
namespace BIS_Tools_DataModels_2025
	{
		/// <summary>
		/// A "smart enum" class representing the different types of emails.
		/// Provides rich data and functionality, including direct comparison to integers.
		/// </summary>
		public sealed class EmailType : IComparable<EmailType>, IEquatable<EmailType>
		{
			// --- Define the static "enum" instances (Corrected) ---

			public static readonly EmailType Spam = new EmailType(0, "Spam", "Spam", "Unsolicited or junk email.", false);
			public static readonly EmailType WRS = new EmailType(1, "WRS", "WRS", "Well Restriction System Submission.", true);
			public static readonly EmailType AutoResponse = new EmailType(2, "AutoResponse", "Auto Response", "Automated reply (e.g., Out of Office).", false);
			public static readonly EmailType BlockedEmail = new EmailType(3, "BlockedEmail", "Blocked Email", "Email blocked by system rules.", false);
			public static readonly EmailType Edd_New = new EmailType(4, "Edd_New", "New EDD", "A new Electronic Data Deliverable submission.", true);
			public static readonly EmailType Edd_Resubmit = new EmailType(5, "Edd_Resubmit", "EDD Resubmit", "A resubmission of a failed Electronic Data Deliverable.", true);
			public static readonly EmailType EDD_Portal = new EmailType(6, "EDD_Portal", "EDD Portal", "An EDD from the portal (initial or duplicate submission).", true);
			public static readonly EmailType EDD_Fix = new EmailType(7, "EDD_Fix", "EDD Fix", "A fix for an HZ/HB issue.", true);
			public static readonly EmailType CEA = new EmailType(8, "CEA", "CEA", "Classification Exception Area Submission.", true);
			public static readonly EmailType DNA = new EmailType(9, "DNA", "DNA", "Deed Notice Application.", true);
			public static readonly EmailType IEC = new EmailType(10, "IEC", "IEC", "Institutional Engineering Control Submission.", true);
			public static readonly EmailType CKE = new EmailType(11, "CKE", "CKE", "CKE Submission (definition pending).", true);
			public static readonly EmailType Multiple = new EmailType(12, "Multiple", "Multiple Types", "Email contains multiple valid submission types.", false);
			public static readonly EmailType Skip = new EmailType(13, "Skip", "Skip", "Email has been marked to be skipped by a user.", false);
			public static readonly EmailType SRP_Forms = new EmailType(14, "SRP_Forms", "SRP Form", "A standard SRP Form submission.", true);
			public static readonly EmailType SRP_Notifications = new EmailType(15, "SRP_Notifications", "SRP Notification", "An automated notification from an SRP system.", false);
			public static readonly EmailType EmptySubjectline = new EmailType(16, "EmptySubjectline", "Empty Subject Line", "Email arrived with no subject line.", false);
			public static readonly EmailType Unknown = new EmailType(17, "Unknown", "Unknown", "The email type could not be determined.", false);


			// --- Properties of each instance ---

			public int Value { get; }
			public string Name { get; }
			public string DisplayName { get; }
			public string Description { get; }
			public bool IsProcessable { get; }

			/// <summary>
			/// Private constructor to prevent arbitrary instantiation.
			/// </summary>
			private EmailType(int value, string name, string displayName, string description, bool isProcessable)
			{
				Value = value;
				Name = name;
				DisplayName = displayName;
				Description = description;
				IsProcessable = isProcessable;
			}

			// --- Static methods for enumeration and lookup ---

			private static readonly IReadOnlyList<EmailType> _allTypes = new List<EmailType>
		{
			Spam, WRS, AutoResponse, BlockedEmail, Edd_New, Edd_Resubmit, EDD_Portal, EDD_Fix,
			CEA, DNA, IEC, CKE, Multiple, Skip, SRP_Forms, SRP_Notifications, EmptySubjectline, Unknown
		};

			public static IEnumerable<EmailType> List() => _allTypes;
			public static IEnumerable<EmailType> ListProcessableTypes() => _allTypes.Where(t => t.IsProcessable);

			public static EmailType FromValue(int value)
			{
				return _allTypes.FirstOrDefault(t => t.Value == value) ?? Unknown;
			}

			public static EmailType FromName(string name)
			{
				if (string.IsNullOrWhiteSpace(name)) return Unknown;
				return _allTypes.FirstOrDefault(t => t.Name.Equals(name, StringComparison.OrdinalIgnoreCase)) ?? Unknown;
			}

			// --- Overrides for standard object behavior ---

			public override string ToString() => DisplayName;

			#region Equality and Comparison (includes Operator Overloads)

			public override bool Equals(object? obj) => obj is EmailType other && Equals(other);

			public bool Equals(EmailType? other) => other is not null && Value.Equals(other.Value);

			public override int GetHashCode() => Value.GetHashCode();

			public int CompareTo(EmailType? other) => other is null ? 1 : Value.CompareTo(other.Value);

			// -- Operator Overloads for comparing two EmailType objects --
			public static bool operator ==(EmailType? left, EmailType? right)
			{
				if (left is null)
				{
					return right is null;
				}
				return left.Equals(right);
			}
			public static bool operator !=(EmailType? left, EmailType? right) => !(left == right);

			// -- Operator Overloads for comparing EmailType and int --
			public static bool operator ==(EmailType? emailType, int value)
			{
				if (emailType is null) return false;
				return emailType.Value == value;
			}
			public static bool operator ==(int value, EmailType? emailType) => emailType == value;

			public static bool operator !=(EmailType? emailType, int value) => !(emailType == value);
			public static bool operator !=(int value, EmailType? emailType) => !(emailType == value);

			#endregion
		}
	}

EXTERNAL DEPENDENCY: IC_Rules_2025 Project
This project contains the core business logic and rules engine.

####FILE: IC_Rules.cs
using BIS_Tools_DataModels_2025;
using Oracle.ManagedDataAccess.Client;
using System.Collections.Generic;
using System.Data;
using System.Data.OleDb;
using System.Globalization;
using System.Linq;
using static BIS_Log;
using static BisFileTools;



namespace IC_Rules_2025
{
    public class IC_Rules
    {
        private string _ReportingClassName = "IC_Rules_2025";

        private BIS_Log _Log;
        private BIS_DB_PostGre _PostGreTool ;
        private BisDbNjems _NjemsTool;
        private BisDbAccess _AccessTool;
        private BisDbCompass _CompassTool;
        private BisFileTools _FileTool;
        private IcNamedTests _NamedICTests;
        private readonly Bis_Regex _regexTool;
        private Dictionary<string, FileSetRule> _filesetRules = new Dictionary<string, FileSetRule>();
        private Dictionary<string, IcGisTypeSetting> _GisTypeSettingRules = new Dictionary<string, IcGisTypeSetting>() ;
        private DataTable _contaminantRulesDt;
        private Dictionary<string,string> _FormationNames = new Dictionary<string,string>() ;
        private Dictionary<string,ReplicaRule> _ReplicaRules = new Dictionary<string,ReplicaRule>() ;
        private Dictionary<string, LayerCopyRule> _LayerCopyRules = new Dictionary<string, LayerCopyRule>();
        private Dictionary<string, VersionPostRule> _VersionPostRules = new Dictionary<string, VersionPostRule>();
        private List<string> _ContaminantsFoundWithoutRules = new List<string>() ;


        public IC_Rules(BIS_Log log, BIS_DB_PostGre? postgreTool = null, BisDbCompass? compassTool = null, BisDbNjems? njemstool = null, BisDbAccess? accessTool = null, BisFileTools? fileTool = null, Bis_Regex? regexTool= null)
        {           
            _Log = log;
            try
            {
            if (postgreTool == null) { _PostGreTool = new BIS_DB_PostGre(_Log); } else { _PostGreTool = postgreTool; } ;
            if (compassTool == null) { _CompassTool = new BisDbCompass(_Log); } else { _CompassTool = compassTool; };
            if (njemstool == null) { _NjemsTool = new BisDbNjems(_Log); } else { _NjemsTool = njemstool; };
            if (accessTool == null) { _AccessTool = new BisDbAccess(_Log); } else { _AccessTool = accessTool; };
            if (fileTool == null) { _FileTool = new BisFileTools(_Log); } else { _FileTool = fileTool; };
            if (regexTool == null) { _regexTool = new Bis_Regex(_Log); } else { _regexTool = regexTool; };

                _NamedICTests = new IcNamedTests(_Log, _PostGreTool);
               // _Log.RecordMessage("About to callloadIcRules", BisLogMessageType.Note);
            loadIcRules();
               // _Log.RecordMessage("Exited callloadIcRules", BisLogMessageType.Note);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error instantiating [IC_Rules]",ex, "IC_Rules");
                throw;
            }
        }

        public Bis_Regex RegexTool => _regexTool;

        public Dictionary<string,VersionPostRule> VersionPostRules
        {
            get { return _VersionPostRules; }
        }

        public List<string> ContaminantsFoundWithoutRules
        {
            get { return _ContaminantsFoundWithoutRules; }
        }

        public Dictionary<string, IcGisTypeSetting> GisTypeSettingRules
        {
            get { return _GisTypeSettingRules; }
        }

        public Dictionary<string, LayerCopyRule> LayerCopyRules
        {
            get { return _LayerCopyRules;} 
        }

        public Dictionary<string, ReplicaRule> ReplicaRules
        {
            get { return _ReplicaRules; }
        }

        /// <summary>
        /// Checks the database to determine if a given ID is a valid Preference ID.
        /// </summary>
        /// <param name="idToCheck">The Preference ID string to validate.</param>
        /// <returns>True if the ID is valid, otherwise false.</returns>
        public bool IsValidPrefId(string idToCheck)
        {
            const string methodName = "IsValidPrefId";
            if (string.IsNullOrWhiteSpace(idToCheck))
            {
                return false;
            }

            // Handle any hardcoded exceptions from the legacy code
            if (idToCheck == "164220")
            {
                _Log.RecordMessage($"Submitted ID ({idToCheck}) is a known invalid Pref ID.", BisLogMessageType.Note);
                return false;
            }

            try
            {
                var paramDict = new Dictionary<string, object> { { "PrefID", idToCheck } };
                // Assuming your NjemsTool is accessible via a property named _NjemsTool
                object queryResult = _NjemsTool.ExecuteNamedQuery("IsValidPrefId", paramDict);
                var dt = (DataTable)queryResult;

                // The ID is valid if the query returns at least one row.
                return (dt != null && dt.Rows.Count > 0);
            }
            catch (Exception ex)
            {
                _Log.RecordError($"An error occurred while validating PrefID '{idToCheck}'.", ex, methodName);
                // Return false on error to prevent proceeding with an unverified ID.
                return false;
            }
        }



        public string ReturnDeliveryMethodForDeliverableId(string deliverableId)
        {
            if (string.IsNullOrEmpty(deliverableId)) { throw new ArgumentNullException(); }
            //List<object> paramList = new List<object>();
            //paramList.Add(deliverableId);
            //string returnValue = "";

            //    returnValue = (string) _PostGreTool.ExecuteNamedQuery("IcDeliveryMethodForDeliverableId", paramList);
            Dictionary<string, object> paramList = new Dictionary<string, object>();
            paramList.Add("a",deliverableId);
            string returnValue = "";

            returnValue = (string)_PostGreTool.ExecuteNamedQuery("IcDeliveryMethodForDeliverableId", paramList);
            return returnValue;
        }

        public Dictionary<string, string> ReturnDeliverableDescriptionForDeliverableId(string deliverableId)
        {
            string methodName = nameof(ReturnDeliverableDescriptionForDeliverableId); 

            if (string.IsNullOrWhiteSpace(deliverableId))
            {
                throw new ArgumentNullException(nameof(deliverableId), "Deliverable ID cannot be null or whitespace.");
            }

            Dictionary<string, string> returnDict = new Dictionary<string, string>();
            string deliverableMethod = "";

                deliverableMethod = ReturnDeliveryMethodForDeliverableId(deliverableId);


            // Use ToUpperInvariant() for case-insensitive comparisons that are not affected by culture.
            switch (deliverableMethod.ToUpperInvariant())
            {
                case "EMAIL":
                    EmailDeliverableInfo delInfo = null;

                        delInfo = ReturnEmailDeliverableInfo(deliverableId);

                    if (delInfo == null)
                    {
                        Exception ex = new Exception($"Email deliverable info was null for ID: {deliverableId}", new NullReferenceException("delInfo was null"));
                        _Log.RecordError("Error returning deliverable description", ex, methodName);
                        throw ex;
                    }
                    returnDict.Add("source", "email");
                    returnDict.Add("outlookId", delInfo.DeliverableEmailId ?? "N/A");
                    returnDict.Add("senderEmail", delInfo.SenderEmail ?? "N/A");
                    returnDict.Add("submitDate", delInfo.SubmitDate ?? "N/A");
                    returnDict.Add("subjectline", delInfo.SubjectLine ?? "N/A");
                    returnDict.Add("templateName", "EmailDeliverableDescription");
                    return returnDict;

                case "PORTAL":
                    PortalDeliverableInfo portalInfo = null;

                        portalInfo = ReturnPortalDeliverableInfo(deliverableId);


                    if (portalInfo == null)
                    {
                        _Log.RecordError($"Portal deliverable info was null for ID: {deliverableId}", new NullReferenceException("portalInfo was null"), methodName);
                        returnDict.Add("error", "Portal deliverable information not found or was null.");
                        returnDict.Add("templateName", "ErrorDescription");
                        return returnDict;
                    }

                    returnDict.Add("source", "portal");
                    returnDict.Add("service_id", portalInfo.ServiceId ?? "N/A");
                    returnDict.Add("submitDate", portalInfo.SubmitDate ?? "N/A");
                    returnDict.Add("senderEmail", portalInfo.SenderEmail ?? "N/A");
                    returnDict.Add("templateName", "PortalDeliverableDescription");
                    return returnDict;

                case "MANUAL":
                    Exception manualEx = new Exception($"Functionality for manual deliverable method ('{deliverableMethod}') is not yet implemented.");
                    _Log.RecordError("Need to build functionality to create deliverable description for Manual submissions", manualEx, methodName);
                    throw manualEx;

                default:
                    Exception unknownEx = new Exception($"Unknown deliverable method ('{deliverableMethod}') encountered.");
                    _Log.RecordError($"Error building deliverable description for deliverable ID ('{deliverableId}') due to unknown method.", unknownEx, methodName);
                    throw unknownEx;
            }
        }
        public PortalDeliverableInfo ReturnPortalDeliverableInfo(string deliverableId)
        {
            string methodName = nameof(ReturnPortalDeliverableInfo);

            Dictionary<string, object> paramDict = new Dictionary<string, object>();
            paramDict.Add("delId", deliverableId);

            DataTable dt = null;
            string qryName = "returnPortalDeliverableSenderinfo";


                dt =(DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            if (dt == null || dt.Rows.Count == 0)
            {
                string errorMessage = $"No deliverable found with the ID ({deliverableId}). Query: {qryName}";
                Exception ex = new Exception(errorMessage);
                _Log.RecordError("Failed to return portal sender information.", ex, methodName);
                throw ex;
            }

            PortalDeliverableInfo info = new PortalDeliverableInfo();
            DataRow firstRow = dt.Rows[0];
            info.SenderEmail = firstRow.IsNull("SUBMITTER_EMAIL") ? "" : Convert.ToString(firstRow["SUBMITTER_EMAIL"]);
            info.SubmitDate = firstRow.IsNull("SUBMITTAL_DATE") ? "" : Convert.ToString(firstRow["SUBMITTAL_DATE"]);
            info.ServiceId = firstRow.IsNull("SERVICE_ID") ? "" : Convert.ToString(firstRow["SERVICE_ID"]);

            return info;
        }

        public EmailDeliverableInfo ReturnEmailDeliverableInfo(string del_Id)
        {
            string methodName = nameof(ReturnEmailDeliverableInfo);

            //List<object> paramList = new List<object>();
            //paramList.Add(del_Id);
            Dictionary<string,Object> paramList = new Dictionary<string,Object>();
            paramList.Add("Del_Id", del_Id);
            DataTable dt = null;
            string qryName = "Return_GIS_DeliverableInfo";

                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramList);


            if (dt == null)
            {
                string errorMessage = $"Error executing the query ({qryName}). DataTable was null.";
                Exception ex = new Exception(errorMessage);
                _Log.RecordError("Failed to return email sender information because DataTable was null.", ex, methodName);
                throw ex;
            }

            EmailDeliverableInfo info = new EmailDeliverableInfo();

            if (dt.Rows.Count == 0)
            {
                info.DeliverableEmailId = "Not found";
                info.SenderEmail = "";
                info.SubmitDate = "";
                info.SubjectLine = "";
                return info;
            }

            DataRow firstRow = dt.Rows[0];

            info.SenderEmail = firstRow.IsNull("SUBMITTER_EMAIL") ? "" : Convert.ToString(firstRow["SUBMITTER_EMAIL"]);
            info.SubmitDate = firstRow.IsNull("SENDDATE") ? "" : Convert.ToString(firstRow["SENDDATE"]);
            info.SubjectLine = firstRow.IsNull("SUBJECTLINE") ? "" : Convert.ToString(firstRow["SUBJECTLINE"]);
            info.DeliverableEmailId = firstRow.IsNull("EMAILID") ? "" : Convert.ToString(firstRow["EMAILID"]);

            return info;
        }

        public void loadIcRules()
        {
            string methodName = nameof(loadIcRules);
            string qryName = "IC_SETTINGS";
            DataTable dt = null;


                dt = (DataTable)_PostGreTool.ExecuteNamedQuery(qryName);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return;
            }

            _GisTypeSettingRules.Clear();

            foreach (DataRow dr in dt.Rows)
            {
                IcGisTypeSetting icSetting = new IcGisTypeSetting();
                string icType = dr.IsNull("ic_type") ? string.Empty : Convert.ToString(dr["ic_type"]).ToUpperInvariant();
                _Log.RecordMessage($"Loading IC Type:{icType}", BisLogMessageType.Note);
                if (string.IsNullOrEmpty(icType))
                {
                    _Log.RecordError("Encountered a row with null or empty 'ic_type' in IC_SETTINGS.", new ArgumentException("ic_type cannot be null or empty."), methodName);
                    continue;
                }
                icSetting.IcType = icType;
                icSetting.AsSubmittedPath = dr.GetStringValue( "assubmittedpath");
                icSetting.TestSenderEmail = dr.GetStringValue("test_email_source");
                icSetting.LoadEmails = dr.GetStringValue("load").Equals("Y", StringComparison.OrdinalIgnoreCase);
                icSetting.TestSet = dr.GetStringValue("testset").Equals("Y", StringComparison.OrdinalIgnoreCase);
                icSetting.IdPrefix = dr.GetStringValue("id_prefix");
                icSetting.EmailTypeValue = dr.GetIntValue("email_type_val");
                icSetting.OutlookInboxFolderPath = dr.GetStringValue("outlook_inbox_path");
                icSetting.OutlookCorrespondenceFolderPath = dr.GetStringValue("correspondence_path");
                icSetting.OutlookProcessedFolderPath = dr.GetStringValue("processed_path");
                icSetting.OutlookSpamFolderPath = dr.GetStringValue("junk_email_path");
                icSetting.ContaminantsQueryName = dr.GetStringValue("njems_contaminants_query");
                icSetting.TasksQueryName = dr.GetStringValue("njems_tasks_query");
                icSetting.NjemsBackgroundQueryName = dr.GetStringValue("njems_background_query");
                icSetting.GeologyQueryName = dr.GetStringValue("njems_geology_query");
                icSetting.ParcelQueryName = dr.GetStringValue("njems_bl_query");
                icSetting.CtnQueryName = dr.GetStringValue("njems_ctn_query");
                icSetting.SiteIdQueryName = dr.GetStringValue("njems_siteid_query");
                icSetting.NjemsSubjectItemQueryName = dr.GetStringValue("njems_subject_item_data");
                icSetting.DocumentsQueryName = dr.GetStringValue("njems_doc_query");
                icSetting.HistoricFillQueryName = dr.GetStringValue("njems_historic_fill_query");
                icSetting.IntDocIdQueryName = dr.GetStringValue("njems_int_doc_query");
                icSetting.IdsOfActiveIcsQueryName = dr.GetStringValue("njems_ids_query");
                icSetting.SubjectItemCategoryCode = dr.GetStringValue("subjectitemcategorycode");
                icSetting.ProposedLayerPath = dr.GetStringValue("proposedlayername");
                icSetting.AutoMergeWithExistingRecentPolygons = dr.GetBooleanValue("mergewithrecentpolygons");


                    icSetting.EmailFolderSet = ReturnOutlookFoldersetForIc(icType);



                    icSetting.AcceptedDatasets = ReturnAcceptedFilesetTypesForIc(icType);



                    icSetting.GeometryRules = ReturnGeometryRulesForIcType(icType);


                    icSetting.FeatureNameFilters = ReturnFeatureFiltersForIcType(icType);


                    icSetting.FeatureFields = ReturnFeatureFieldsForIcType(icType);



                    icSetting.ProposedFeatureClass = ReturnFeatureclassSettings(dr.GetStringValue("proposedfeatureclass"));



                    icSetting.ShapeInfoTable = ReturnFeatureclassSettings(dr.GetStringValue("shape_info_table"));


                    icSetting.FinalFeatureClass = ReturnFeatureclassSettings(dr.GetStringValue("finalfeatureclass"));


                    icSetting.FieldUpdateRules = ReturnFieldUpdateRulesForIcType( icType);

                _GisTypeSettingRules.Add(icType, icSetting);
            }


                LoadFilesetTypeRules();


                _contaminantRulesDt =(DataTable) _PostGreTool.ExecuteNamedQuery("returnAllContaminantRules");


                LoadGeologyFormations();



                LoadLayerCopyRules();


                LoadVersionPostRules();


        }

        public IcGisTypeSetting ReturnIcGisTypeSettings(string icType)
        {
            if (!_GisTypeSettingRules.ContainsKey(icType))
            {
                throw new Exception($"Unknown IC Type ({icType}).");
            }
            return _GisTypeSettingRules[icType.ToUpper()];
        }


        private void LoadVersionPostRules()
        {
            string methodName = nameof(LoadVersionPostRules);
            string qryName = "returnVersionPushRules"; 
            DataTable dt = null;

            _VersionPostRules.Clear(); 

                dt =(DataTable) _PostGreTool.ExecuteNamedQuery(qryName);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return; // Cannot proceed
            }

            foreach (DataRow dr in dt.Rows)
            {
                VersionPostRule vpr = new VersionPostRule(); // Constructor initializes lists and complex types
                string ruleName = "";

                    ruleName = dr.GetStringValue("post_rule_name");
                    if (string.IsNullOrWhiteSpace(ruleName))
                    {
                        _Log.RecordError("Version post rule name is empty or null. Skipping row.", new DataException("Version post rule name cannot be empty."), methodName);
                        continue; // Skip this rule
                    }

                    vpr.PostRuleName = ruleName;
                    vpr.FromWorkspace = ReturnWorkspaceRule(dr.GetStringValue("edit_workspace"));
                    vpr.ToWorkspace = ReturnWorkspaceRule(dr.GetStringValue("target_workspace"));
                    vpr.LastReconcileDate = dr.GetDateTimeValue( "last_reconcile_date");
                    vpr.Prep_Rules = ReturnPushPrepRules(ruleName); // Placeholder for this function
                    vpr.EmailBodyTemplateText = dr.GetStringValue("bodytext");
                vpr.EmailSubjectlineText = dr.GetStringValue("subjecttext");
                    vpr.EmailRecipients = ReturnRecipientsList(dr.GetStringValue("email_recipient_list")); // Placeholder

                    if (!_VersionPostRules.ContainsKey(ruleName))
                    {
                        _VersionPostRules.Add(ruleName, vpr);
                    }
                    else
                    {
                        _Log.RecordError($"Duplicate ruleName '{ruleName}' found in version post rules. Skipping duplicate.", new ArgumentException($"Duplicate ruleName: {ruleName}"), methodName);
                    }

            }
        }
        private List<EmailRecipient> ReturnRecipientsList(string listName) 
        {
            string methodName = nameof(ReturnRecipientsList);
            string qryName = "returnRecipientsInEmailList";
            DataTable dt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>();

            // Handle potential null or empty listName early
            if (string.IsNullOrWhiteSpace(listName))
            {
                _Log.RecordError("listName cannot be null or whitespace in ReturnRecipientsList.", new ArgumentNullException(nameof(listName)), methodName);
                return new List<EmailRecipient>(); // Return empty list
            }
            paramDict.Add("listName", listName);


                dt =(DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            List<EmailRecipient> returnList = new List<EmailRecipient>();

            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for listName '{listName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return returnList; // Return empty list
            }

            foreach (DataRow dr in dt.Rows)
            {
                EmailRecipient newRecipient = new EmailRecipient();
                try
                {
                    newRecipient.Address = dr.GetStringValue("recipient_address");
                    newRecipient.RecipientType = dr.GetStringValue("recipient_type").ToLowerInvariant(); // Convert to lowercase as in VB

                    // Assuming there's a column "recipient_name" for the name,
                    // as VB's .recipientName = IIf(IsDBNull(dr("recipient_type")), "", dr("recipient_type")) was likely a typo.
                    newRecipient.RecipientName = dr.GetStringValue("recipient_type");

                    returnList.Add(newRecipient);
                }
                catch (Exception ex)
                {
                    _Log.RecordError($"Error processing recipient row for listName '{listName}'. Address: '{dr.GetStringValue("recipient_address")}'. Error: {ex.Message}", ex, methodName);
                    // Optionally continue or re-throw
                    throw;
                }
            }
            return returnList;
        }

        public DataRow ReturnShapeInfo(string shapeId)
        {
            string methodName = "ReturnShapeInfo";
            string qryName = "returnAllShapeInfoData"; // The name of the query to execute
                                                       //List<object> paramList = new List<object>();
                                                       //paramList.Add(shapeId);

            Dictionary<string, Object> paramList = new Dictionary<string, Object>();
            paramList.Add("Del_Id", shapeId);
            DataTable dt;
            try
            {
                // Call the PostgreSQL tool to execute the query
                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramList);
            }
            catch (Exception ex)
            {
                _Log.RecordError($"Error retrieving shape information for ({shapeId}).", ex, methodName);
                throw; // Re-throw the exception to be handled by the caller or a global handler
            }

            if (dt == null || dt.Rows.Count == 0)
            {
                _Log.RecordMessage($"No shape information returned for ({shapeId}).", BisLogMessageType.Note, 1);
                return null; // Return null if no data is found
            }
            return dt.Rows[0]; // Return the first row of the DataTable
        }

        public GeologyData ReturnGeologyData(string shape_id)
        {
            string methodName = "ReturnGeologyData(string)"; // Method signature for clarity in logs
            GeologyData returnValue = new GeologyData();
            returnValue.Valid = true; // Assume valid until proven otherwise

            // String interpolation for formatted error message
            string genErrMsg = $"Failed to return geology information for ({shape_id}).";

            DataRow dr = ReturnShapeInfo(shape_id); // Call the method to get shape info

            if (dr == null)
            {
                // If no DataRow is returned, it implies the shape_id was not found or an error occurred in ReturnShapeInfo.
                // Log this specific scenario.
                _Log.RecordMessage($"No shape information found for shape_id ({shape_id}). Cannot proceed to get geology data.", BisLogMessageType.Warning, 1);
                returnValue.Valid = false;
                return returnValue;
            }

            string icType = "";
            if (dr.IsNull("ic_type") || string.IsNullOrWhiteSpace(dr["ic_type"].ToString()))
            {
                _Log.RecordMessage($"No ic_type recorded for ({shape_id}).", BisLogMessageType.Note, 1);
                returnValue.Valid = false;
                return returnValue;
            }
            else
            {
                icType = dr["ic_type"].ToString();
            }

            int intDocId;
            if (dr.IsNull("int_doc_id"))
            {
                _Log.RecordMessage($"No int_doc_id recorded for ({shape_id}).", BisLogMessageType.Note, 1);
                returnValue.Valid = false;
                return returnValue;
            }
            else
            {
                // It's good practice to try-parse in case the data isn't a valid integer.
                if (int.TryParse(dr["int_doc_id"].ToString(), out int parsedDocId))
                {
                    intDocId = parsedDocId;
                }
                else
                {
                    _Log.RecordMessage($"Invalid int_doc_id format for ({shape_id}): '{dr["int_doc_id"]}'.", BisLogMessageType.Warning, 1);
                    returnValue.Valid = false;
                    return returnValue;
                }
            }

            int subjItemId;
            if (dr.IsNull("subject_item_id"))
            {
                _Log.RecordMessage($"No subject_item_id recorded for ({shape_id}).", BisLogMessageType.Note, 1);
                returnValue.Valid = false;
                return returnValue;
            }
            else
            {
                if (int.TryParse(dr["subject_item_id"].ToString(), out int parsedSubjItemId))
                {
                    subjItemId = parsedSubjItemId;
                }
                else
                {
                    _Log.RecordMessage($"Invalid subject_item_id format for ({shape_id}): '{dr["subject_item_id"]}'.", BisLogMessageType.Warning, 1);
                    returnValue.Valid = false;
                    return returnValue;
                }
            }

            // Call the other ReturnGeologyData function with the retrieved parameters
            // Any exceptions from this call will propagate up, or you can catch them here if specific handling is needed.
            try
            {
                return ReturnGeologyData(intDocId, subjItemId, icType);
            }
            catch (Exception ex)
            {
                // Log the error with the context of the shape_id
                _Log.RecordError($"{genErrMsg} - Error during call to detailed ReturnGeologyData.", ex, methodName);
                returnValue.Valid = false;
                return returnValue; // Return the geologyData object with valid = false
            }
        }

        public GeologyData ReturnGeologyData(int int_doc_id, int subject_item_id, string icType)
        {
            string methodName = nameof(ReturnGeologyData);
            GeologyData returnValue = new GeologyData();
            returnValue.Valid = true;
            string genErrMsg = "Failed to return geology information.";

            if (!_GisTypeSettingRules.ContainsKey(icType))
            {
                Exception ex = new Exception($"Unknown IC Type {icType} recorded.");
                _Log.RecordError(genErrMsg, ex, methodName);
                throw ex;
            }

            IcGisTypeSetting icSetting = _GisTypeSettingRules[icType];

            string geologySqlName = icSetting.GeologyQueryName;
            if (string.IsNullOrEmpty(geologySqlName))
            {
                _Log.RecordMessage($"No geology query found for ({icType}).", BisLogMessageType.Note, 1);
                return returnValue;
            }

            DataTable geologyDt = null;

            Dictionary<string, object> paramDict = new Dictionary<string, object>();
            paramDict.Add("int_doc_id", int_doc_id);
            paramDict.Add("subject_item_id", subject_item_id);

            try
            {
                geologyDt =(DataTable) _NjemsTool.ExecuteNamedQuery(geologySqlName, paramDict);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error querying for geology information.", ex, methodName);
                throw; // Re-throw preserving stack trace
            }

            Bis_Regex regexTool = new Bis_Regex(_Log); // Assuming _Log might be a dependency for BIS_Regex
            double totalDepth = 0;
            List<string> formationList = new List<string>();
            char[] trimChars = new char[] { ' ', '.' };

            try
            {
                if (geologyDt != null) // Ensure geologyDt is not null before iterating
                {
                    foreach (DataRow dr in geologyDt.Rows)
                    {
                        string depthStr = dr.IsNull("FORMATION_DEPTH_MSR") ? "0" : dr["FORMATION_DEPTH_MSR"].ToString();

                        // First look for dashes (ex 12-20 ft) and take the substring to the right
                        int parsePos = depthStr.LastIndexOf("-");
                        if (parsePos > -1) // LastIndexOf returns -1 if not found
                        {
                            // Ensure parsePos + 1 is within bounds
                            if (parsePos + 1 < depthStr.Length)
                                depthStr = depthStr.Substring(parsePos + 1);
                            else depthStr = ""; // or handle as appropriate
                        }

                        // Do the same for ' to ' (case-sensitive, use StringComparison for case-insensitive)
                        parsePos = depthStr.LastIndexOf(" to ", StringComparison.OrdinalIgnoreCase);
                        if (parsePos > -1)
                        {
                            // Ensure parsePos + " to ".Length is within bounds
                            if (parsePos + " to ".Length < depthStr.Length)
                                depthStr = depthStr.Substring(parsePos + " to ".Length);
                            else depthStr = ""; // or handle as appropriate
                        }

                        depthStr = depthStr.Trim(trimChars);

                        string cleanedDepthStr = regexTool.ReplaceUsingNamedExpression(depthStr, "removeNonDigits");
                        if (string.IsNullOrEmpty(cleanedDepthStr)) cleanedDepthStr = "0";

                        // If the original string had both a period and a decimal point then both will still be here
                        // This trimming might be redundant if regex already handles it, but kept for fidelity
                        cleanedDepthStr = cleanedDepthStr.Trim(trimChars);

                        // Attempt to parse, provide default on failure
                        if (double.TryParse(cleanedDepthStr, NumberStyles.Any, CultureInfo.InvariantCulture, out double currentDepth))
                        {
                            totalDepth += currentDepth;
                        }
                        else
                        {
                            // Optionally log a warning if parsing fails for a non-empty, non-"0" string
                            if (cleanedDepthStr != "0")
                                _Log.RecordMessage($"Could not parse depth string '{cleanedDepthStr}' from original '{dr["FORMATION_DEPTH_MSR"]}'. Using 0.", BisLogMessageType.Warning, 2);
                        }


                        string njemsFormationName = dr.IsNull("GEO_FORMATION_CODE") ? "" : dr["GEO_FORMATION_CODE"].ToString();
                        if (_FormationNames.ContainsKey(njemsFormationName) && !string.IsNullOrEmpty(_FormationNames[njemsFormationName]) && !formationList.Contains(_FormationNames[njemsFormationName]))
                        {
                            formationList.Add(_FormationNames[njemsFormationName]);
                        }
                    }
                }
                returnValue.TotalDepth = totalDepth;
                returnValue.Formation = string.Join(", ", formationList);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Something flukey happened interpreting geology info from NJEMS.", ex, methodName);
                returnValue.Valid = false;
                // No need to return returnValue here if we are not inside a finally block that would otherwise return.
                // The final return will handle it. If this try block is the last significant operation before returning,
                // then returning here is fine to short-circuit.
                // For safety and clarity given the original structure:
                return returnValue;
            }

            return returnValue;
        }




        public List<string>FillInParameters(string textToUpdate, Dictionary<string,string> paramaterValues)
        {
            return _NamedICTests.fillInParameters(textToUpdate, paramaterValues);
        }

        private List<IcPushPrepRule> ReturnPushPrepRules(string ruleName)
        {
            string methodName = nameof(ReturnPushPrepRules);
            List<IcPushPrepRule> listToReturn = new List<IcPushPrepRule>();
            DataTable dt = null;
            string qryName = "returnPostPrepRules";
            //List<object> paramList = new List<object>();
            Dictionary<String,Object> paramList  = new Dictionary<String, Object>();

            if (string.IsNullOrWhiteSpace(ruleName))
            {
                _Log.RecordError("ruleName cannot be null or whitespace in ReturnPushPrepRules.", new ArgumentNullException(nameof(ruleName)), methodName);
                return listToReturn; // Return empty list
            }
            //paramList.Add(ruleName); // VB code did not UCase this, so keeping it as is.
            paramList.Add("a",ruleName); // VB code did not UCase this, so keeping it as is.

            dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramList);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for ruleName '{ruleName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return listToReturn; // Return empty list
            }

            foreach (DataRow dr in dt.Rows)
            {
                IcPushPrepRule prepRule = new IcPushPrepRule(); // Constructor initializes complex types
                try
                {
                    prepRule.FeatureclassToPrep = ReturnFeatureclassSettings(dr.GetStringValue("featureclass_to_prep"));
                    prepRule.ActiveFeatureclass = ReturnFeatureclassSettings(dr.GetStringValue("gis_active_featureclass"));
                    prepRule.ArchiveWorkspace = ReturnWorkspaceRule(dr.GetStringValue("archive_workspace"));
                    prepRule.CountTemplateTest = dr.GetStringValue("replacementtext");
                    listToReturn.Add(prepRule);
                }
                catch (Exception ex)
                {
                    _Log.RecordError($"Error processing push prep rule for ruleName '{ruleName}'. Error: {ex.Message}", ex, methodName);
                    throw;
                }
            }
            return listToReturn;
        }


        private void LoadLayerCopyRules()
        {
            string methodName = nameof(LoadLayerCopyRules);
            string qryName = "ReturnLayerCopyRules";
            DataTable dt = null;

            _LayerCopyRules.Clear(); // Assuming LayerCopyRules is initialized in the constructor


                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return; // Cannot proceed
            }

            foreach (DataRow dr in dt.Rows)
            {
                LayerCopyRule lr = new LayerCopyRule(); // Constructor initializes complex types
                string layerRuleName = "";

                try
                {
                    layerRuleName = dr.GetStringValue("copy_rule_name");
                    if (string.IsNullOrWhiteSpace(layerRuleName))
                    {
                        _Log.RecordError("Layer copy rule name is empty or null. Skipping row.", new DataException("Layer copy rule name cannot be empty."), methodName);
                        continue; // Skip this rule
                    }

                    lr.LayerPath =  dr.GetStringValue("layer_path");
                    lr.SourceFc = ReturnFeatureclassSettings(dr.GetStringValue("source_fc"));
                    lr.LayerName = dr.GetStringValue("layer_name");
                    lr.DestinationWs = ReturnWorkspaceRule(dr.GetStringValue("destination_ws"));

                    string sourceTableName = dr.GetStringValue("source_table_name");
                    if (string.IsNullOrWhiteSpace(sourceTableName))
                    {
                        lr.IncludeJoinTable = false;
                    }
                    else
                    {
                        lr.IncludeJoinTable = true;
                        lr.SourceTable = ReturnFeatureclassSettings(sourceTableName); // Assuming table settings are also loaded via FeatureclassSettings structure
                        lr.SourceJoinField = dr.GetStringValue("source_join_field");
                        lr.DestJoinField = dr.GetStringValue("dest_join_field");
                    }

                    lr.Def_qry = dr.GetStringValue("def_query"); // Consider renaming property to DefinitionQuery

                    // Assuming "delete_previous_copies" is a boolean-like value (Y/N, 1/0, True/False)
                    lr.DelPreviousCopies = dr.GetBooleanValue("delete_previous_copies");

                    // Properties like CurDestFcName, CurDestTableName, CurFcName, CurTableName are not set from DB in VB.
                    // They are likely set at runtime, so we don't populate them here.

                    if (!_LayerCopyRules.ContainsKey(layerRuleName))
                    {
                        _LayerCopyRules.Add(layerRuleName, lr);
                    }
                    else
                    {
                        _Log.RecordError($"Duplicate layerRuleName '{layerRuleName}' found. Skipping duplicate.", new ArgumentException($"Duplicate layerRuleName: {layerRuleName}"), methodName);
                    }
                }
                catch (Exception ex)
                {
                    _Log.RecordError($"Error loading layer copy rule '{layerRuleName}'. Error: {ex.Message}", ex, methodName);
                    // Depending on policy, re-throw or continue
                    throw;
                }
            }
        }


        private WorkSpaceRule ReturnWorkspaceRule(string workspaceName)
        {
            string methodName = nameof(ReturnWorkspaceRule);
            WorkSpaceRule workspaceRule = new WorkSpaceRule(); // Initialize with default values

            if (string.IsNullOrWhiteSpace(workspaceName))
            {
                _Log.RecordError("workspaceName cannot be null or whitespace in ReturnWorkspaceRule. Returning default rule.",
                                 new ArgumentNullException(nameof(workspaceName)), methodName);
                return workspaceRule; // Return a default/empty rule
            }

            string qryName = "returnWorkspaceRule"; 
            DataTable dt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>();
            paramDict.Add("workspaceName", workspaceName); // Parameter name from VB


                dt =(DataTable)  _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for workspaceName '{workspaceName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return workspaceRule; // Return default/empty rule
            }

            if (dt.Rows.Count == 0)
            {
                _Log.RecordError($"No workspace rule found for workspaceName '{workspaceName}' using query '{qryName}'. Returning default rule.", new DataException("No rows returned for workspace rule."), methodName);
                return workspaceRule;
            }

            DataRow dr = dt.Rows[0]; 

            workspaceRule.Instance = dr.GetStringValue("instance");
            workspaceRule.Server = dr.GetStringValue("server");
            workspaceRule.User = dr.GetStringValue("logonuser");
            workspaceRule.Version = dr.GetStringValue(  "version");
            workspaceRule.WorkspaceName = dr.GetStringValue("workspacename"); 
            workspaceRule.Database = dr.GetStringValue("database");
            workspaceRule.Password = dr.GetStringValue("pw");
            workspaceRule.WorkspaceType = dr.GetStringValue("workspace_type");
            workspaceRule.ConnectionName = dr.GetStringValue("connection_name");
            workspaceRule.Port  = dr.GetIntValue("port"); 
            return workspaceRule;
        }

        private void LoadReplicaRules()
        {
            string methodName = nameof(LoadReplicaRules);
            string qryName = "ReturnReplicaRules";
            DataTable dt = null;

            _ReplicaRules.Clear();


                dt =(DataTable) _PostGreTool.ExecuteNamedQuery(qryName);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return; // Cannot proceed
            }

            foreach (DataRow dr in dt.Rows)
            {
                ReplicaRule rr = new ReplicaRule(); // Constructor initializes ParentWorkspace and ChildWorkspace
                string replicaRuleName = ""; // To store the key for the dictionary

                try
                {
                    replicaRuleName = dr.GetStringValue("replicarulename");
                    if (string.IsNullOrWhiteSpace(replicaRuleName))
                    {
                        _Log.RecordError("Replica rule name is empty or null. Skipping row.", new DataException("Replica rule name cannot be empty."), methodName);
                        continue; // Skip this rule
                    }

                    rr.ChildReplicaName = dr.GetStringValue("child_replica_name");
                    rr.ParentReplicaName = dr.GetStringValue("parent_replica_name");

                    string childWorkspaceName = dr.GetStringValue("child_replica_workspace");
                    if (string.IsNullOrWhiteSpace(childWorkspaceName))
                    {
                        throw new DataException($"Child workspace name not defined for replica rule '{replicaRuleName}'.");
                    }

                    string parentWorkspaceName = dr.GetStringValue("parent_replica_workspace");
                    if (string.IsNullOrWhiteSpace(parentWorkspaceName))
                    {
                        throw new DataException($"Parent workspace name not defined for replica rule '{replicaRuleName}'.");
                    }

                    // Assuming ReturnWorkspaceRule is a method that fetches/constructs a WorkSpaceRule object
                    // This method would need to be defined in SettingsService or be accessible.
                    rr.ChildWorkspace = ReturnWorkspaceRule(childWorkspaceName);
                    rr.ParentWorkspace = ReturnWorkspaceRule(parentWorkspaceName);

                    if (!_ReplicaRules.ContainsKey(replicaRuleName))
                    {
                        _ReplicaRules.Add(replicaRuleName, rr);
                    }
                    else
                    {
                        _Log.RecordError($"Duplicate replicaRuleName '{replicaRuleName}' found. Skipping duplicate.", new ArgumentException($"Duplicate replicaRuleName: {replicaRuleName}"), methodName);
                    }
                }
                catch (Exception ex)
                {
                    _Log.RecordError($"Error loading replica rule '{replicaRuleName}'. Error: {ex.Message}", ex, methodName);
                    throw;
                }
            }
        }



        private void LoadGeologyFormations()
        {
            string methodName = nameof(LoadGeologyFormations);
            _FormationNames.Clear(); // Assuming FormationNames is initialized in constructor
            DataTable formationDt = null;
            string qryName = "returnGeologyFormations";


                formationDt =(DataTable)  _PostGreTool.ExecuteNamedQuery(qryName);


            if (formationDt == null)
            {
                _Log.RecordError($"Query '{qryName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return; // Cannot proceed
            }

            foreach (DataRow dr in formationDt.Rows)
            {
                // Assuming the first column (index 0) is sourceName and second (index 1) is truncatedName
                string sourceName = dr.GetStringValue(dr.Table.Columns[0].ColumnName);
                string truncatedName = dr.GetStringValue(dr.Table.Columns[1].ColumnName);

                if (!string.IsNullOrEmpty(sourceName)) // Ensure sourceName is not empty before adding
                {
                    if (!_FormationNames.ContainsKey(sourceName))
                    {
                        _FormationNames.Add(sourceName, truncatedName);
                    }
                    else
                    {
                        // Log or handle duplicate sourceName if necessary
                        _Log.RecordError($"Duplicate sourceName '{sourceName}' found while loading geology formations. Using first encountered value.", new ArgumentException($"Duplicate sourceName: {sourceName}"), methodName);
                    }
                }
            }
        }

        private void LoadFilesetTypeRules()
        {
            string methodName = nameof(LoadFilesetTypeRules);
            string qryNameFilesetTypes = "filesetTypes";
            DataTable dtFilesetTypes = null;

            _filesetRules.Clear(); // cKnownFilesetRules equivalent
            List<string> filesetNames = new List<string>();


                dtFilesetTypes =(DataTable) _PostGreTool.ExecuteNamedQuery(qryNameFilesetTypes);


            if (dtFilesetTypes == null)
            {
                _Log.   RecordError($"Query '{qryNameFilesetTypes}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return; // Cannot proceed without fileset types
            }

            foreach (DataRow dr in dtFilesetTypes.Rows)
            {
                // Assuming the first column (index 0) contains the fileset type name
                filesetNames.Add(dr.GetStringValue(dr.Table.Columns[0].ColumnName));
            }

            Dictionary<string, object> paramDict = new Dictionary<string, object>();
            paramDict.Add("filesetTypeName", ""); // Placeholder, will be updated in the loop

            string qryNameRules = "returnRulesForFileset";
            foreach (string filesetName in filesetNames)
            {
                if (string.IsNullOrWhiteSpace(filesetName)) continue; // Skip if filesetName is empty

                paramDict["filesetTypeName"] = filesetName;
                DataTable dtRules = null;

                    dtRules = (DataTable) _PostGreTool.ExecuteNamedQuery(qryNameRules, paramDict);


                if (dtRules == null)
                {
                    _Log.RecordError($"Query '{qryNameRules}' for filesetName '{filesetName}' returned a null DataTable.", new NullReferenceException("DataTable for rules was null."), methodName);
                    continue; // Skip this fileset type
                }

                FileSetRule filesetRule = new FileSetRule(); // Constructor initializes lists

                if (dtRules.Rows.Count > 0) // Basic properties can be taken from the first row
                {
                    DataRow firstRuleRow = dtRules.Rows[0];
                    filesetRule.FilesetTypeName = filesetName; // Set from the loop variable
                    filesetRule.GeneralType = firstRuleRow.GetStringValue(  "generaltype");
                    filesetRule.SubsetOf = firstRuleRow.GetStringValue("subsetof");
                }
                else // If no rules found for this fileset type, still add it with its name
                {
                    filesetRule.FilesetTypeName = filesetName;
                }


                foreach (DataRow drRule in dtRules.Rows)
                {
                    string extension = drRule.GetStringValue("extension");
                    if (string.IsNullOrWhiteSpace(extension)) continue;

                    // Check for "required" column and its value
                    string requiredStr = drRule.GetStringValue("required");
                    if (requiredStr.Equals("Y", StringComparison.OrdinalIgnoreCase))
                    {
                        filesetRule.RequiredExtensions.Add(extension);
                    }
                    else
                    {
                        filesetRule.OptionalExtensions.Add(extension);
                    }
                }

                if (!_filesetRules.ContainsKey(filesetName))
                {
                    _filesetRules.Add(filesetName, filesetRule);
                }
                else
                {
                    _Log.RecordError($"Duplicate filesetName '{filesetName}' encountered while loading fileset rules. Overwriting.", new ArgumentException($"Duplicate filesetName: {filesetName}"), methodName);
                    _filesetRules[filesetName] = filesetRule; // Overwrite if duplicate, or handle as error
                }
            }
        }


        private List<IcFieldUpdateRule> ReturnFieldUpdateRulesForIcType(string icType)
        {
            string methodName = nameof(ReturnFieldUpdateRulesForIcType);
            List<IcFieldUpdateRule> returnVal = new List<IcFieldUpdateRule>();

            string qryName = "fieldUpdateRulesForIcType";
            DataTable dt = null;
            //List<object> paramList = new List<object>(); // Using List<object> as per VB
            Dictionary<String, Object> paramList = new Dictionary<String, Object>();
            if (string.IsNullOrWhiteSpace(icType))
            {
                _Log.RecordError("icType cannot be null or whitespace in ReturnFieldUpdateRulesForIcType.", new ArgumentNullException(nameof(icType)), methodName);
                return returnVal; // Return empty list
            }
            //paramList.Add(icType.ToUpperInvariant());
            paramList.Add("a",icType.ToUpperInvariant());

            // Assuming CPostGreTool has an ExecuteNamedQueryUsingList method
            dt =(DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramList);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for icType '{icType}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return returnVal; // Return empty list
            }

            if (dt.Rows.Count == 0)
            {
                return returnVal; // No rules found, return empty list
            }

            foreach (DataRow dr in dt.Rows)
            {
                IcFieldUpdateRule newRule = new IcFieldUpdateRule();
                try // Add try-catch around individual row processing for robustness
                {
                    newRule.FieldName = dr.GetStringValue("fieldname");
                    newRule.Source = dr.GetStringValue("source");
                    newRule.SourceFieldName = dr.GetStringValue("sourcefieldname");
                    newRule.DisplayOrder = dr.GetIntValue("displayorder"); 
                    newRule.MaxFieldLength = dr.GetShortValue("maxfieldlength");
                    newRule.FieldType = dr.GetOracleDbTypeValue("fieldtype", OleDbType.VarChar); // Default to Varchar2

                    newRule.Display = dr.GetBooleanValue("show");
                    newRule.AllowEdit = dr.GetBooleanValue("editable");
                    newRule.UseProperCase = dr.GetBooleanValue("propercase");
                    newRule.Required = dr.GetBooleanValue("required");
                    newRule.IsIdField = dr.GetBooleanValue("idfield");
                    newRule.CopyToFinal = dr.GetBooleanValue("copytofinal");
                    newRule.IsEmailAddress = dr.GetBooleanValue("is_email_address");

                    string transferValue = dr.GetStringValue("njems_data_transfer");
                    switch (transferValue.ToUpperInvariant())
                    {
                        case "ALWAYS":
                            newRule.UpdateNjems = WhenToTransferToNJEMS.Always;
                            break;
                        case "WHEN EMPTY":
                            newRule.UpdateNjems = WhenToTransferToNJEMS.WhenEmpty;
                            break;
                        default:
                            newRule.UpdateNjems = WhenToTransferToNJEMS.Never;
                            break;
                    }
                    returnVal.Add(newRule);
                }
                catch (Exception ex)
                {
                    _Log.RecordError($"Error processing field update rule row for field '{dr.GetStringValue("fieldname")}'. Error: {ex.Message}", ex, methodName);
                    // Optionally continue to next row or re-throw depending on desired error handling
                }
            }
            return returnVal;
        }


        private FeatureclassRule ReturnFeatureclassSettings(string featureclassName)
        {
            string methodName = nameof(ReturnFeatureclassSettings);
            FeatureclassRule featureClassRule = new FeatureclassRule(); // Initialize with default values

            // Handle cases where featureclassName might be null or empty,
            // which could happen if the corresponding column in IC_SETTINGS is null/empty.
            if (string.IsNullOrWhiteSpace(featureclassName))
            {
                _Log.RecordError("featureclassName cannot be null or whitespace in ReturnFeatureclassSettings. Returning default rule.",
                                 new ArgumentNullException(nameof(featureclassName)), methodName);
                return featureClassRule; // Return a default/empty rule
            }

            string qryName = "ReturnFeatureclassRule";
            DataTable dt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>();
            paramDict.Add("Fc_Name", featureclassName); // Using the provided featureclassName


                dt =(DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for featureclassName '{featureclassName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return featureClassRule; // Return default/empty rule
            }

            if (dt.Rows.Count == 0)
            {
                // Original VB code returned the new (empty) featureClassRule here.
                _Log.RecordError($"No feature class rule found for featureclassName '{featureclassName}' using query '{qryName}'. Returning default rule.", new DataException("No rows returned for feature class rule."), methodName);
                return featureClassRule;
            }

            DataRow dr = dt.Rows[0]; // Assuming only one rule per featureclassName

            featureClassRule.FeatureClassName = featureclassName; // Set from parameter
            featureClassRule.PostGreFeatureClassName = dr.GetStringValue("sde_featureclass_name");
            featureClassRule.DefaultLayerTemplate = dr.GetStringValue("default_layer_template");

            // Populate the nested WorkSpaceRule object
            featureClassRule.WorkSpaceRule.Instance = dr.GetStringValue("instance");
            featureClassRule.WorkSpaceRule.Server = dr.GetStringValue("server");
            featureClassRule.WorkSpaceRule.User = dr.GetStringValue("logonuser");
            featureClassRule.WorkSpaceRule.Version = dr.GetStringValue("version");
            featureClassRule.WorkSpaceRule.WorkspaceName = dr.GetStringValue("workspacename");
            featureClassRule.WorkSpaceRule.Database = dr.GetStringValue("database");
            featureClassRule.WorkSpaceRule.Password = dr.GetStringValue("pw");
            featureClassRule.WorkSpaceRule.WorkspaceType = dr.GetStringValue("workspace_type");
            featureClassRule.WorkSpaceRule.ConnectionName = dr.GetStringValue("connection_name");
            featureClassRule.WorkSpaceRule.Port = dr.GetIntValue("port");
            return featureClassRule;
        }

        public string CaseHasHistoricFill(int pi_id, int int_doc_id, int subject_item_id, string icType)
        {
            string methodName = nameof(CaseHasHistoricFill);
            string genErrMsg = "Failed to return NJEMS historic fill activity information.";

            if (string.IsNullOrEmpty(icType) || !_GisTypeSettingRules.ContainsKey(icType))
            {
                string icTypeDisplay = string.IsNullOrEmpty(icType) ? "[NULL_OR_EMPTY]" : icType;
                Exception ex = new Exception($"Unknown or missing IC Type {icTypeDisplay} recorded.");
                _Log.RecordError(genErrMsg, ex, methodName);
                throw ex;
            }

            IcGisTypeSetting icSetting = _GisTypeSettingRules[icType];

            string njemsHistoricFillQueryName = icSetting.HistoricFillQueryName;
            if (string.IsNullOrEmpty(njemsHistoricFillQueryName))
            {
                _Log.RecordMessage($"No NJEMS Historic Fill data query found for IC Type ({icType}).", BisLogMessageType.Note, 1);
                return null; // VB returned Nothing, which is reference type null. C# string can be null.
            }

            DataTable njemsDt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>
        {
            { "int_doc_id", int_doc_id },
            { "pi_id", pi_id },
            { "subject_item_id", subject_item_id }
        };

            try
            {
                njemsDt =(DataTable) _NjemsTool.ExecuteNamedQuery(njemsHistoricFillQueryName, paramDict);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error querying for NJEMS Historic Fill data information.", ex, methodName);
                throw ; // Re-throw the exception
            }

            if (njemsDt != null && njemsDt.Rows.Count > 0)
            {
                return "Yes";
            }
            else
            {
                return "No";
            }
        }

        public string ReturnParcelData(int int_doc_id, int subject_item_id, string icType)
        {
            string methodName = nameof(ReturnParcelData);
            string genErrMsg = "Failed to return parcel information.";
            string returnValue = "";

            if (string.IsNullOrEmpty(icType) || !_GisTypeSettingRules.ContainsKey(icType))
            {
                string icTypeDisplay = string.IsNullOrEmpty(icType) ? "[NULL_OR_EMPTY]" : icType;
                Exception ex = new Exception($"Unknown IC Type {icTypeDisplay} recorded.");
                _Log.RecordError(genErrMsg, ex, methodName);
                throw ex;
            }

            IcGisTypeSetting icSetting = _GisTypeSettingRules[icType];
            string parcelSqlName = icSetting.ParcelQueryName;

            if (string.IsNullOrEmpty(parcelSqlName))
            {
                _Log.RecordMessage($"No parcel query found for ({icType}).", BisLogMessageType.Note, 1);
                return ""; // Return empty string as per VB
            }

            Dictionary<string, object> paramDict = new Dictionary<string, object>
        {
            { "int_doc_id", int_doc_id },
            { "subject_item_id", subject_item_id }
        };

            DataTable parcelDatatable;
            try
            {
                parcelDatatable = (DataTable) _NjemsTool.ExecuteNamedQuery(parcelSqlName, paramDict);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error querying for parcel information.", ex, methodName);
                throw ex;
            }

            try
            {
                List<string> parcelList = new List<string>();
                if (parcelDatatable != null)
                {
                    foreach (DataRow dr in parcelDatatable.Rows)
                    {
                        string block = dr.IsNull("BLOCK_DESC") ? "" : dr["BLOCK_DESC"].ToString();
                        string lot = dr.IsNull("LOT_DESC") ? "" : dr["LOT_DESC"].ToString();
                        bool emptyValueFound = false;

                        if (string.IsNullOrEmpty(block))
                        {
                            _Log.RecordMessage("Block value empty for this NJEMS record", BisLogMessageType.Note, 3);
                            emptyValueFound = true;
                        }
                        if (string.IsNullOrEmpty(lot))
                        {
                            _Log.RecordMessage("Lot value empty for this NJEMS record", BisLogMessageType.Note, 3);
                            emptyValueFound = true;
                        }

                        if (!emptyValueFound)
                        {
                            parcelList.Add($"{block}-{lot}");
                        }
                    }
                }

                if (parcelList.Count > 0)
                {
                    returnValue = string.Join("; ", parcelList);
                }
                else
                {
                    returnValue = "";
                }

                // Original VB: If Len(returnValue) > 100 Then returnValue = "See Report"
                if (returnValue.Length > 100)
                {
                    returnValue = "See Report";
                }
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error preparing the parcel data.", ex, methodName);
                return ""; // Return empty string on error as per VB
            }
            return returnValue;
        }

        public string ReturnParcelData(string shape_id)
        {
            string methodName = nameof(ReturnParcelData);
            // string genErrMsg = $"Failed to return parcel information for ({shape_id})."; // Not used in VB for this overload

            DataRow dr = ReturnShapeInfo(shape_id);
            if (dr == null)
            {
                return ""; // Return empty string as per VB
            }

            string icType = "";
            if (dr.IsNull("ic_type") || string.IsNullOrWhiteSpace(dr["ic_type"].ToString()))
            {
                _Log.RecordMessage($"No ic_type recorded for ({shape_id}).", BisLogMessageType.Note, 1);
                return "";
            }
            else
            {
                icType = dr["ic_type"].ToString();
            }

            int intDocId;
            if (dr.IsNull("int_doc_id") || !int.TryParse(dr["int_doc_id"].ToString(), out intDocId))
            {
                _Log.RecordMessage($"No or invalid int_doc_id recorded for ({shape_id}): '{dr["int_doc_id"]}'.", BisLogMessageType.Warning, 1);
                return "";
            }

            int subjItemId;
            if (dr.IsNull("subject_item_id") || !int.TryParse(dr["subject_item_id"].ToString(), out subjItemId))
            {
                _Log.RecordMessage($"No or invalid subject_item_id recorded for ({shape_id}): '{dr["subject_item_id"]}'.", BisLogMessageType.Warning, 1);
                return "";
            }

            try
            {
                // Call the detailed ReturnParcelData function
                return ReturnParcelData(intDocId, subjItemId, icType);
            }
            catch (Exception ex)
            {
                // The detailed function already logs and throws. If it throws, this will propagate.
                // If we want to catch and return "" like the other checks in this overload:
                _Log.RecordError($"Error calling detailed ReturnParcelData for shape_id ({shape_id}).", ex, methodName);
                return "";
            }
        }


        public Dictionary<string, string> ReturnContaminantData(string shape_id)
        {
            string methodName = nameof(ReturnContaminantData);
            // Using StringComparer.CurrentCultureIgnoreCase for the dictionary as in VB
            Dictionary<string, string> returnValue = new Dictionary<string, string>(StringComparer.CurrentCultureIgnoreCase);
            string genErrMsg = $"Failed to return contaminant information for ({shape_id}).";

            DataRow dr = ReturnShapeInfo(shape_id);
            if (dr == null)
            {
                // Log message already handled in ReturnShapeInfo or if it returns null without logging, add one here.
                // _Log.recordMessage($"No shape information found for shape_id ({shape_id}). Cannot retrieve contaminant data.", Bis_Log_Message_Type.Warning, 1);
                return returnValue; // Return empty dictionary
            }

            string icType = "";
            if (dr.IsNull("ic_type") || string.IsNullOrWhiteSpace(dr["ic_type"].ToString()))
            {
                _Log.RecordMessage($"No ic_type recorded for ({shape_id}).", BisLogMessageType.Note, 1);
                return returnValue;
            }
            else
            {
                icType = dr["ic_type"].ToString();
            }

            int intDocId;
            if (dr.IsNull("int_doc_id") || !int.TryParse(dr["int_doc_id"].ToString(), out intDocId))
            {
                _Log.RecordMessage($"No or invalid int_doc_id recorded for ({shape_id}): '{dr["int_doc_id"]}'.", BisLogMessageType.Warning, 1);
                return returnValue;
            }

            int subjItemId;
            if (dr.IsNull("subject_item_id") || !int.TryParse(dr["subject_item_id"].ToString(), out subjItemId))
            {
                _Log.RecordMessage($"No or invalid subject_item_id recorded for ({shape_id}): '{dr["subject_item_id"]}'.", BisLogMessageType.Warning, 1);
                return returnValue;
            }

            try
            {
                // Call the detailed ReturnContaminantData function
                return ReturnContaminantData(intDocId, subjItemId, icType);
            }
            catch (Exception ex)
            {
                // Log the error with the context of the shape_id
                _Log.RecordError($"{genErrMsg} - Error during call to detailed ReturnContaminantData.", ex, methodName);
                // Return an empty dictionary in case of an error during the call to the detailed method,
                // or null if that's the contract for errors from the detailed method.
                // The detailed method returns null in some error cases, so we should propagate that or convert to empty.
                // For consistency with other shape_id overloads, returning an empty dictionary might be better than null.
                return returnValue; // Return empty dictionary on error
            }
        }

        public Dictionary<string, string> ReturnContaminantData(int int_doc_id, int subject_item_id, string icType)
        {
            string methodName = nameof(ReturnContaminantData);
            string genErrMsg = "Failed to return contaminant information.";
            // Using StringComparer.CurrentCultureIgnoreCase for the dictionary as in VB
            Dictionary<string, string> returnDictionary = new Dictionary<string, string>(StringComparer.CurrentCultureIgnoreCase);

            if (string.IsNullOrEmpty(icType) || !_GisTypeSettingRules.ContainsKey(icType))
            {
                string icTypeDisplay = string.IsNullOrEmpty(icType) ? "[NULL_OR_EMPTY]" : icType;
                Exception ex = new Exception($"Unknown IC Type {icTypeDisplay} recorded.");
                _Log.RecordError(genErrMsg, ex, methodName);
                throw ex;
            }

            IcGisTypeSetting icSetting = _GisTypeSettingRules[icType];
            string contamSqlName = icSetting.ContaminantsQueryName;

            if (string.IsNullOrEmpty(contamSqlName))
            {
                _Log.RecordMessage($"No contaminant query found for ({icType}).", BisLogMessageType.Note, 1);
                return returnDictionary; // Return empty dictionary
            }

            Dictionary<string, object> paramDict = new Dictionary<string, object>
        {
            { "subject_item_id", subject_item_id },
            { "int_doc_id", int_doc_id }
            // pi_id is not used in this specific query's parameters in the VB example,
            // but could be added if your actual SQL query needs it.
        };

            DataTable contaminantDt;
            try
            {
                contaminantDt =(DataTable) _NjemsTool.ExecuteNamedQuery(contamSqlName, paramDict);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error querying for contaminant information.", ex, methodName);
                throw ;
            }

            // Structure: FieldName -> { 0: "ReportingStyle (Flag/List)", PriorityOrIndex: "ContaminantName/Yes" }
            Dictionary<string, Dictionary<int, string>> contamFieldValues = new Dictionary<string, Dictionary<int, string>>();

            string groupRefFieldName = icType + "_Contaminant_Group";
            string asFlagRefFieldName = icType + "_ReportAsFlag";

            // Ensure the rule table has the necessary columns before proceeding
            if (!_contaminantRulesDt.Columns.Contains(groupRefFieldName) || !_contaminantRulesDt.Columns.Contains(asFlagRefFieldName))
            {
                _Log.RecordMessage($"Contaminant rule table cContaminantRulesDt is missing required columns for icType '{icType}': '{groupRefFieldName}' or '{asFlagRefFieldName}'.", BisLogMessageType.Note, 1);
                return returnDictionary; // Or throw an exception, depending on desired error handling
            }


            DataView contamRulesDataView = new DataView(_contaminantRulesDt);

            try
            {
                if (contaminantDt != null)
                {
                    foreach (DataRow siteContam in contaminantDt.Rows)
                    {
                        string reportedParam = siteContam.IsNull("PARAMETER_CODE") ? "" : siteContam["PARAMETER_CODE"].ToString();
                        if (string.IsNullOrEmpty(reportedParam)) continue;

                        contamRulesDataView.RowFilter = $"PARAMETER_CODE = '{reportedParam.Replace("'", "''")}'"; // Handle apostrophes in param code for RowFilter

                        if (contamRulesDataView.Count == 0)
                        {
                            if (!_ContaminantsFoundWithoutRules.Contains(reportedParam))
                            {
                                _ContaminantsFoundWithoutRules.Add(reportedParam);
                                _Log.RecordMessage($"No rule found for the contaminant ({reportedParam}).", BisLogMessageType.Note, 2);
                            }
                            continue; // GoTo nextContaminant
                        }

                        DataRowView curContamRule = contamRulesDataView[0];

                        string srpReportingFlag = curContamRule.Row.IsNull("SRP_REPORTING_FLAG") ? "" : curContamRule["SRP_REPORTING_FLAG"].ToString();
                        if (!srpReportingFlag.Equals("Y", StringComparison.OrdinalIgnoreCase))
                        {
                            _Log.RecordMessage($"SRP is not concerned with the contaminant ({reportedParam}).", BisLogMessageType.Warning);
                            continue; // GoTo nextContaminant
                        }

                        // string paramCode = curContamRule.Row.IsNull("PARAMETER_CODE") ? "" : curContamRule["PARAMETER_CODE"].ToString(); // Already have as reportedParam
                        string paramDescription = curContamRule.Row.IsNull("PARAMETER_DESC") ? "" : curContamRule["PARAMETER_DESC"].ToString();
                        string contamReportingField = curContamRule.Row.IsNull(groupRefFieldName) ? "" : curContamRule[groupRefFieldName].ToString();
                        string contamReportAsFlagRaw = curContamRule.Row.IsNull(asFlagRefFieldName) ? "" : curContamRule[asFlagRefFieldName].ToString();
                        string contamReportAsFlagUpper = contamReportAsFlagRaw.ToUpper();

                        if (string.IsNullOrEmpty(contamReportingField))
                        {
                            _Log.RecordMessage($"Contaminant rule for ({reportedParam}) has no GIS reporting field ({groupRefFieldName}) defined for icType '{icType}'.", BisLogMessageType.Warning, 2);
                            continue;
                        }


                        if (!contamFieldValues.ContainsKey(contamReportingField))
                        {
                            contamFieldValues.Add(contamReportingField, new Dictionary<int, string>());
                        }

                        Dictionary<int, string> currentFieldDict = contamFieldValues[contamReportingField];

                        if (!string.IsNullOrEmpty(contamReportAsFlagUpper)) // "Y" or a number
                        {
                            currentFieldDict[0] = "Flag"; // Mark as Flag reporting style
                            int dictIndex = 1; // Default for "Y"
                            string reportStr = "Yes";

                            if (int.TryParse(contamReportAsFlagRaw, out int priority)) // If it's a number, use it as priority
                            {
                                dictIndex = priority;
                                reportStr = paramDescription;
                            }

                            // Add or update based on priority. Higher numeric value for contamReportAsFlagRaw means higher priority.
                            // If we already have an entry for this index, only overwrite if the new reportStr is different (e.g. "Yes" vs a specific name)
                            // Or, if the existing entry is "Yes" and new one is a specific name, prefer specific name.
                            // The original VB logic implies that a higher numeric contamReportAsFlagRaw is more important.
                            // And if multiple map to the same numeric flag, the last one processed wins.
                            // If it's just "Y", it gets index 1.
                            if (!currentFieldDict.ContainsKey(dictIndex) || currentFieldDict[dictIndex] == "Yes" || reportStr != "Yes")
                            {
                                currentFieldDict[dictIndex] = reportStr;
                            }
                        }
                        else // Not a flag, so report as a list
                        {
                            currentFieldDict[0] = "List"; // Mark as List reporting style
                                                          // Add to the list, ensuring unique index (Count + 1 is a simple way if keys are sequential)
                                                          // The original VB code uses `contamFieldValues(contamReportingField).Count + 1`.
                                                          // This assumes keys 1, 2, 3... are used for list items.
                                                          // Key 0 is reserved for "List" or "Flag".
                            int nextKey = 1;
                            while (currentFieldDict.ContainsKey(nextKey)) nextKey++;
                            currentFieldDict.Add(nextKey, paramDescription);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _Log.RecordError("Unexpected error occurred building contaminant information.", ex, methodName);
                return null; // Return null on error, as per VB's `Return Nothing` in this block
            }

            // Now translate the reported contaminants into a single string for each GIS field
            try
            {
                foreach (KeyValuePair<string, Dictionary<int, string>> kvp in contamFieldValues)
                {
                    string contamFieldName = kvp.Key;
                    Dictionary<int, string> fieldData = kvp.Value;
                    string contamFieldVal = "";

                    if (fieldData.TryGetValue(0, out string reportingStyle))
                    {
                        if (reportingStyle == "Flag")
                        {
                            // Find the highest priority (largest key) for "Flag" type. Key 0 is style.
                            int maxKey = 0;
                            foreach (int key in fieldData.Keys)
                            {
                                if (key == 0) continue; // Skip reporting style key
                                if (key > maxKey) maxKey = key;
                            }
                            if (maxKey > 0 && fieldData.ContainsKey(maxKey)) // Ensure there's at least one flag value
                            {
                                contamFieldVal = fieldData[maxKey];
                            }
                            else
                            {
                                // This case might happen if only the style "Flag" was set but no actual value (e.g. "Yes" or a prioritized name)
                                // Default to "No" or empty, or handle as an error/log. Original VB implies it would be empty.
                                contamFieldVal = ""; // Or "No" if that's more appropriate
                            }
                        }
                        else if (reportingStyle == "List")
                        {
                            List<string> contamList = fieldData.Where(item => item.Key != 0) // Exclude style key
                                                               .Select(item => item.Value)
                                                               .Distinct() // Ensure unique contaminant names in the list
                                                               .ToList();
                            contamList.Sort(); // Sort alphabetically
                            contamFieldVal = string.Join(", ", contamList);
                        }
                    }
                    if (!string.IsNullOrEmpty(contamFieldName)) // Only add if field name is valid
                    {
                        returnDictionary[contamFieldName] = contamFieldVal; // Use [] to add or update
                    }
                }
            }
            catch (Exception ex)
            {
                _Log.RecordError("Unexpected error occurred condensing the contaminant information.", ex, methodName);
                return null; // Return null on error
            }

            return returnDictionary;
        }

        public FileSetRule ReturnFilesetRule(string ruleName)
        {
            string methodName = "ReturnFilesetRule";

            if (!_filesetRules.ContainsKey(ruleName))
            {
                Exception ex = new Exception($"Unknown fileset ({ruleName}).");
                _Log.RecordError("Error obtaining fileset rule.", ex, methodName);
                throw ex;
            }
            return _filesetRules[ruleName];
        }

        public List<string> ReturnIcTypes(bool justIcTypesFlaggedToLoad = true)
        {
            List<string> returnList = new List<string>();
            foreach (KeyValuePair<string,IcGisTypeSetting> kvp in _GisTypeSettingRules)
            {
                if ((justIcTypesFlaggedToLoad) || kvp.Value.LoadEmails) { returnList.Add(kvp.Key); }
            }
            return returnList;
        }

        public bool isKnownIcType(string icTpyeName)
        {
            return _GisTypeSettingRules.Keys.Any(k => k.Equals(icTpyeName, StringComparison.OrdinalIgnoreCase));
        }


        public DataRow ReturnNjemsBackgroundData(string shape_id)
        {
            string methodName = nameof(ReturnNjemsBackgroundData);
            string genErrMsg = $"Failed to return NJEMS background information for ({shape_id}).";

            DataRow drShapeInfo = ReturnShapeInfo(shape_id); // Renamed for clarity from 'dr'
            if (drShapeInfo == null)
            {
                // ReturnShapeInfo already logs if no data is found.
                return null;
            }

            string icType = "";
            if (drShapeInfo.IsNull("ic_type") || string.IsNullOrWhiteSpace(drShapeInfo["ic_type"].ToString()))
            {
                _Log.RecordMessage($"No ic_type recorded for ({shape_id}).", BisLogMessageType.Note, 1);
                return null;
            }
            else
            {
                icType = drShapeInfo["ic_type"].ToString();
            }

            int intDocId;
            if (drShapeInfo.IsNull("int_doc_id") || !int.TryParse(drShapeInfo["int_doc_id"].ToString(), out intDocId))
            {
                _Log.RecordMessage($"No or invalid int_doc_id recorded for ({shape_id}): '{drShapeInfo["int_doc_id"]}'.", BisLogMessageType.Warning, 1);
                return null;
            }

            int pi_id; // pi_id is needed for the detailed call
            if (drShapeInfo.IsNull("pi_id") || !int.TryParse(drShapeInfo["pi_id"].ToString(), out pi_id))
            {
                _Log.RecordMessage($"No or invalid pi_id recorded for ({shape_id}): '{drShapeInfo["pi_id"]}'.", BisLogMessageType.Warning, 1);
                return null;
            }

            int subjItemId;
            if (drShapeInfo.IsNull("subject_item_id") || !int.TryParse(drShapeInfo["subject_item_id"].ToString(), out subjItemId))
            {
                _Log.RecordMessage($"No or invalid subject_item_id recorded for ({shape_id}): '{drShapeInfo["subject_item_id"]}'.", BisLogMessageType.Warning, 1);
                return null;
            }

            try
            {
                // Call the detailed ReturnNjemsBackgroundData function
                return ReturnNjemsBackgroundData(pi_id, intDocId, subjItemId, icType);
            }
            catch (Exception ex)
            {
                _Log.RecordError($"{genErrMsg} - Error during call to detailed ReturnNjemsBackgroundData.", ex, methodName);
                return null; // Return null on error, consistent with the detailed method's error path
            }
        }

        public DataRow ReturnNjemsBackgroundData(int pi_id, int int_doc_id, int subject_item_id, string icType)
        {
            string methodName = nameof(ReturnNjemsBackgroundData);
            string genErrMsg = "Failed to return NJEMS background information.";

            if (string.IsNullOrEmpty(icType) || !_GisTypeSettingRules.ContainsKey(icType))
            {
                string icTypeDisplay = string.IsNullOrEmpty(icType) ? "[NULL_OR_EMPTY]" : icType;
                Exception ex = new Exception($"Unknown or missing IC Type {icTypeDisplay} recorded.");
                _Log.RecordError(genErrMsg, ex, methodName);
                throw ex;
            }

            IcGisTypeSetting icSetting = _GisTypeSettingRules[icType];

            string njemsBackgroundDataSqlName = icSetting.NjemsBackgroundQueryName;
            if (string.IsNullOrEmpty(njemsBackgroundDataSqlName))
            {
                _Log.RecordMessage($"No NJEMS background data query found for IC Type ({icType}).", BisLogMessageType.Note, 1);
                return null;
            }

            DataTable njemsDt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>
        {
            { "int_doc_id", int_doc_id },
            { "pi_id", pi_id },
            { "subject_item_id", subject_item_id }
        };

            try
            {
                njemsDt = (DataTable) _NjemsTool.ExecuteNamedQuery(njemsBackgroundDataSqlName, paramDict);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error querying for NJEMS background data information.", ex, methodName);
                throw ; // Re-throw the exception
            }

            if (njemsDt == null || njemsDt.Rows.Count == 0)
            {
                _Log.RecordMessage("No NJEMS background data returned.", BisLogMessageType.Note, 1);
                return null;
            }
            return njemsDt.Rows[0];
        }

        public Dictionary<string, string> LoadCssStyles()
        {
            string methodName = nameof(LoadCssStyles);
            // Using StringComparer.OrdinalIgnoreCase for CSS style names, assuming they might be case-insensitive in practice
            Dictionary<string, string> cssStyles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            DataTable dt = null;
            string qryName = "returnAllCssStyles";


                // Assuming cPostGreTool.executeNamedQuery can be called without a parameter list
                // If it always requires a list, pass an empty one: cPostGreTool.executeNamedQuery(qryName, new List<object>());
                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName);


            if (dt != null)
            {
                foreach (DataRow dr in dt.Rows)
                {
                    // Ensure column names match what cPostGreTool.executeNamedQuery("returnAllCssStyles") returns
                    string styleName = dr.IsNull("stylename") ? string.Empty : dr["stylename"].ToString();
                    string styleDef = dr.IsNull("stylecode") ? string.Empty : dr["stylecode"].ToString();

                    if (!string.IsNullOrEmpty(styleName)) // Only add if styleName is not empty
                    {
                        if (!cssStyles.ContainsKey(styleName))
                        {
                            cssStyles.Add(styleName, styleDef);
                        }
                        else
                        {
                            // Optionally log if a duplicate style name is found but ignored
                            _Log.RecordMessage($"Duplicate CSS style name '{styleName}' found and ignored.", BisLogMessageType.Note, 2);
                        }
                    }
                }
            }
            return cssStyles;
        }

        /// <summary>
        /// Scans a directory for files and groups them by filename (case-insensitive), 
        /// returning a dictionary mapping filenames (without extension) to a list of their extensions (uppercase).
        /// This method does NOT search subdirectories.
        /// </summary>
        /// <param name="folderToCheck">The directory path to scan.</param>
        /// <returns>A dictionary where the key is the uppercase filename without extension,
        /// and the value is a list of unique uppercase extensions found for that filename.</returns>
        private Dictionary<string, List<string>> ReturnUniqueFilenames(string folderToCheck)
        {
            string methodName = nameof(ReturnUniqueFilenames);
            // Use OrdinalIgnoreCase for case-insensitive filename comparison, common on Windows but explicit is better.
            var filesFound = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
            try
            {
                // Get all files in the current directory. SearchOption.TopDirectoryOnly is default.
                string[] files = Directory.GetFiles(folderToCheck);

                foreach (string f in files)
                {
                    // Use path methods for robust extraction.
                    string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(f);
                    string extension = Path.GetExtension(f); // Includes the dot, e.g., ".pdf"

                    // Normalize filename and extension (e.g., to uppercase as in VB example)
                    string normalizedFileName = fileNameWithoutExtension.ToUpperInvariant();
                    string normalizedExtension = extension.TrimStart('.').ToUpperInvariant(); // Remove leading dot and uppercase

                    if (string.IsNullOrEmpty(normalizedFileName)) continue; // Skip files with no name (e.g., ".config")

                    // Add filename key if it doesn't exist
                    if (!filesFound.ContainsKey(normalizedFileName))
                    {
                        filesFound.Add(normalizedFileName, new List<string>());
                    }

                    // Add the extension if it's not already in the list for this filename
                    if (!string.IsNullOrEmpty(normalizedExtension) && !filesFound[normalizedFileName].Contains(normalizedExtension))
                    {
                        filesFound[normalizedFileName].Add(normalizedExtension);
                    }
                }
            }
            catch (UnauthorizedAccessException uaEx)
            {
                _Log.RecordError($"Access denied while collecting unique file names in the folder ({folderToCheck}).", uaEx, methodName);
                // Optionally re-throw or return empty dictionary depending on desired behavior
                // throw; 
            }
            catch (DirectoryNotFoundException dnfEx)
            {
                _Log.RecordError($"Directory not found while collecting unique file names: ({folderToCheck}).", dnfEx, methodName);
                // Optionally re-throw or return empty dictionary
                // throw;
            }
            catch (Exception ex) // Catch other potential exceptions (IOExceptions, etc.)
            {
                _Log.RecordError($"Error collecting unique file names in the folder ({folderToCheck}).", ex, methodName);
                throw; // Re-throw unexpected errors
            }

            return filesFound;
        }

        /// <summary>
        /// Recursively searches a directory for filesets based on defined rules.
        /// Can rename files with problematic characters and identifies filesets by their extensions.
        /// </summary>
        /// <param name="pathToSearch">The root directory path to start the search.</param>
        /// <param name="icType">Optional. The IC Type to filter applicable fileset rules and apply priorities. 
        /// If empty, all known fileset rules are considered without specific priority.</param>
        /// <param name="searchSubFolders">Optional. If true (default), searches subfolders recursively.</param>
        /// <returns>A list of found fileset objects, potentially sorted by priority if icType is provided.</returns>
        /// 

        //public List<fileset> ReturnFileSetsFromDirectory(string pathToSearch, string icType = "", bool searchSubFolders = false)
        //{
        //    string methodName = "ReturnFileSetsFromDirectory";
        //    List<fileset> filesetsFound = new List<fileset>();

        //    try
        //    {
        //        if (!Directory.Exists(pathToSearch))
        //        {
        //            _Log.RecordMessage($"Directory not found: {pathToSearch}", BisLogMessageType.Warning, 1);
        //            return filesetsFound;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Log.RecordError($"Error checking directory existence: {pathToSearch}", ex, methodName);
        //        return filesetsFound;
        //    }

        //    if (!string.IsNullOrEmpty(icType) && !_GisTypeSettingRules.ContainsKey(icType))
        //    {
        //        _Log.RecordMessage("No IC Type provided for all filesets getting returned.", BisLogMessageType.Note);
        //    }

        //    if (searchSubFolders)
        //    {
        //        try
        //        {
        //            string[] subDirectories = Directory.GetDirectories(pathToSearch);
        //            foreach (string folder in subDirectories)
        //            {
        //                filesetsFound.AddRange(ReturnFileSetsFromDirectory(folder, icType, searchSubFolders));
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error processing subfolders in {pathToSearch}.", ex, methodName);
        //        }
        //    }

        //    Dictionary<string, List<string>> uniqueFileNamesInCurrentDir = ReturnUniqueFilenames(pathToSearch);
        //    Dictionary<string, string> renamedFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        //    List<string> filenamesToCheck = uniqueFileNamesInCurrentDir.Keys.ToList();

        //    foreach (string originalFileNameKey in filenamesToCheck)
        //    {
        //        if (originalFileNameKey.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;

        //        string cleanedFilename = originalFileNameKey.Replace("-", "_").Replace(".", "_").Replace("~", "_");

        //        if (originalFileNameKey != cleanedFilename)
        //        {
        //            if (uniqueFileNamesInCurrentDir.ContainsKey(cleanedFilename) && cleanedFilename != originalFileNameKey)
        //            {
        //                _Log.RecordMessage($"Target cleaned filename ({cleanedFilename}) already exists. Skipping rename of ({originalFileNameKey}) in '{pathToSearch}'.", BisLogMessageType.Warning, 2);
        //                continue;
        //            }

        //            _Log.RecordMessage($"File ({originalFileNameKey}) in path '{pathToSearch}' will be processed for renaming to ({cleanedFilename}).", BisLogMessageType.Note, 1);
        //            bool renameSuccessful = true;
        //            List<string> extensions = uniqueFileNamesInCurrentDir[originalFileNameKey];
        //            List<Tuple<string, string>> renameOperations = new List<Tuple<string, string>>();
        //            foreach (string ext in extensions)
        //            {
        //                string oldFullPath = Path.Combine(pathToSearch, originalFileNameKey + "." + ext);
        //                string newFullPath = Path.Combine(pathToSearch, cleanedFilename + "." + ext);
        //                renameOperations.Add(Tuple.Create(oldFullPath, newFullPath));
        //            }

        //            foreach (var op in renameOperations)
        //            {
        //                try
        //                {
        //                    File.Copy(op.Item1, op.Item2, true);
        //                    File.Delete(op.Item1);
        //                }
        //                catch (Exception ex)
        //                {
        //                    _Log.RecordError($"Error renaming file part '{op.Item1}' to '{op.Item2}'.", ex, methodName);
        //                    renameSuccessful = false;
        //                    break;
        //                }
        //            }

        //            if (renameSuccessful)
        //            {
        //                renamedFiles.Add(cleanedFilename, originalFileNameKey);
        //                uniqueFileNamesInCurrentDir.Add(cleanedFilename, extensions);
        //                uniqueFileNamesInCurrentDir.Remove(originalFileNameKey);
        //            }
        //            else
        //            {
        //                _Log.RecordMessage($"Rename failed for base file ({originalFileNameKey}) in '{pathToSearch}'. Original files might remain.", BisLogMessageType.Warning, 1);
        //            }
        //        }
        //    }

        //    List<string> fileTypeNamesToCheckFor = new List<string>();
        //    if (string.IsNullOrEmpty(icType))
        //    {
        //        fileTypeNamesToCheckFor.AddRange(_filesetRules.Keys);
        //    }
        //    else
        //    {
        //        fileTypeNamesToCheckFor.AddRange(_GisTypeSettingRules[icType].AcceptedDatasets.Select(d => d.DatasetTypeName));
        //    }

        //    // --- START OF MODIFIED LOGIC ---
        //    List<string> processedFileNames = new List<string>();
        //    var orderedRules = fileTypeNamesToCheckFor.Distinct()
        //        .OrderBy(ruleName => _filesetRules.ContainsKey(ruleName) && !string.IsNullOrEmpty(_filesetRules[ruleName].SubsetOf))
        //        .ToList();

        //    foreach (string filesetRuleName in orderedRules)
        //    {
        //        if (!_filesetRules.ContainsKey(filesetRuleName)) continue;

        //        FileSetRule fileSetRule = _filesetRules[filesetRuleName];

        //        foreach (string baseFileName in uniqueFileNamesInCurrentDir.Keys)
        //        {
        //            if (processedFileNames.Contains(baseFileName, StringComparer.OrdinalIgnoreCase)) continue;
        //            if (baseFileName.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;

        //            var foundExtensions = uniqueFileNamesInCurrentDir[baseFileName];
        //            var requiredExtensionsFound = fileSetRule.RequiredExtensions
        //                .Where(reqExt => foundExtensions.Any(e => e.Equals(reqExt, StringComparison.OrdinalIgnoreCase))).ToList();
        //            var optionalExtensionsFound = fileSetRule.OptionalExtensions
        //                .Where(optExt => foundExtensions.Any(e => e.Equals(optExt, StringComparison.OrdinalIgnoreCase))).ToList();

        //            if (requiredExtensionsFound.Any() || optionalExtensionsFound.Any())
        //            {
        //                var allFoundExtensions = requiredExtensionsFound.Union(optionalExtensionsFound).ToList();

        //                fileset fs = new fileset
        //                {
        //                    fileName = baseFileName,
        //                    path = pathToSearch,
        //                    filesetType = fileSetRule.FilesetTypeName,
        //                    extensions = allFoundExtensions
        //                };

        //                if (renamedFiles.TryGetValue(baseFileName, out string originalNameBeforeCleaning))
        //                {
        //                    fs.originalFileName = originalNameBeforeCleaning;
        //                }

        //                fs.validSet = (fileSetRule.RequiredExtensions.Count == requiredExtensionsFound.Count);
        //                filesetsFound.Add(fs);
        //                processedFileNames.Add(baseFileName);
        //            }
        //        }
        //    }
        //    // --- END OF MODIFIED LOGIC ---

        //    return filesetsFound.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                      .Select(g => g.First())
        //                      .ToList();
        //}

        public List<fileset> ReturnFileSetsFromDirectory_NewMethod(string pathToSearch, string icType = "", bool searchSubFolders = false)
        {
            string methodName = "ReturnFileSetsFromDirectory";
            var finalFilesets = new List<fileset>();

            if (!Directory.Exists(pathToSearch))
            {
                _Log.RecordMessage($"Directory not found: {pathToSearch}", BisLogMessageType.Warning, 1);
                return finalFilesets;
            }

            // --- START OF NEW, SIMPLIFIED LOGIC ---

            // 1. Recursively find all filesets in subdirectories first.
            if (searchSubFolders)
            {
                try
                {
                    foreach (string folder in Directory.GetDirectories(pathToSearch))
                    {
                        finalFilesets.AddRange(ReturnFileSetsFromDirectory_NewMethod(folder, icType, true));
                    }
                }
                catch (Exception ex)
                {
                    _Log.RecordError($"Error processing subfolders in {pathToSearch}.", ex, methodName);
                }
            }

            // 2. Get all unique files in the current directory.
            var uniqueFileNamesInCurrentDir = ReturnUniqueFilenames(pathToSearch);
            if (!uniqueFileNamesInCurrentDir.Any()) return finalFilesets;

            var acceptedRuleNames = string.IsNullOrEmpty(icType)
                ? _filesetRules.Keys.ToList()
                : _GisTypeSettingRules[icType].AcceptedDatasets.Select(d => d.DatasetTypeName).ToList();

            var acceptedRules = _filesetRules.Values
                .Where(r => acceptedRuleNames.Contains(r.FilesetTypeName, StringComparer.OrdinalIgnoreCase)).ToList();

            // 3. Process each group of files (e.g., all files with the base name "site")
            foreach (var fileGroup in uniqueFileNamesInCurrentDir)
            {
                string baseFileName = fileGroup.Key;
                var foundExtensions = fileGroup.Value;

                FileSetRule bestMatchRule = null;
                int maxRequiredFound = -1;

                // Find the BEST rule that matches this group of files.
                foreach (var rule in acceptedRules)
                {
                    int requiredFoundCount = rule.RequiredExtensions
                        .Count(req => foundExtensions.Any(f => f.Equals(req, StringComparison.OrdinalIgnoreCase)));

                    int optionalFoundCount = rule.OptionalExtensions
                        .Count(opt => foundExtensions.Any(f => f.Equals(opt, StringComparison.OrdinalIgnoreCase)));

                    if (requiredFoundCount > 0 || optionalFoundCount > 0)
                    {
                        if (requiredFoundCount > maxRequiredFound)
                        {
                            maxRequiredFound = requiredFoundCount;
                            bestMatchRule = rule;
                        }
                    }
                }

                if (bestMatchRule == null) continue;

                // 4. Create a SINGLE, unambiguous fileset object for what was submitted.
                var finalRequiredFound = bestMatchRule.RequiredExtensions
                    .Where(req => foundExtensions.Any(f => f.Equals(req, StringComparison.OrdinalIgnoreCase))).ToList();
                var finalOptionalFound = bestMatchRule.OptionalExtensions
                    .Where(opt => foundExtensions.Any(f => f.Equals(opt, StringComparison.OrdinalIgnoreCase))).ToList();

                var originalFileset = new fileset
                {
                    fileName = baseFileName,
                    path = pathToSearch,
                    filesetType = bestMatchRule.FilesetTypeName,
                    extensions = finalRequiredFound.Union(finalOptionalFound).ToList(),
                    validSet = (bestMatchRule.RequiredExtensions.Count == finalRequiredFound.Count)
                };

                finalFilesets.Add(originalFileset);

                // 5. If the original fileset was an incomplete subset, attempt to "repair" it.
                if (!string.IsNullOrEmpty(bestMatchRule.SubsetOf) && !originalFileset.validSet)
                {
                    _Log.RecordMessage($"Attempting to repair incomplete subset: {originalFileset.fileName}", BisLogMessageType.Note);

                    // --- THIS IS THE PLACEHOLDER FOR YOUR FUTURE REPAIR LOGIC ---
                    // For now, we'll simulate a successful repair.
                    // In the future, this would call your geometry extraction logic.
                    bool repairWasSuccessful = false; // Placeholder

                    if (repairWasSuccessful)
                    {
                        var repairedFileset = new fileset
                        {
                            fileName = $"{baseFileName}_Repaired",
                            path = pathToSearch,
                            filesetType = "SHAPEFILE", // The result of a repair is always a shapefile
                            extensions = originalFileset.extensions, // It has the same files for now
                            validSet = true, // A repaired fileset is considered valid
                            originalFileName = baseFileName
                        };
                        finalFilesets.Add(repairedFileset);
                        _Log.RecordMessage($"Successfully repaired '{baseFileName}'. A new fileset '{repairedFileset.fileName}' was created.", BisLogMessageType.Note);
                    }
                    // --- END OF PLACEHOLDER ---
                }
            }

            // --- END OF SIMPLIFIED LOGIC ---
            return finalFilesets;
        }


        //public List<fileset> ReturnFileSetsFromDirectory_bak(string pathToSearch, string icType = "", bool searchSubFolders = false)
        //{
        //    string methodName = "ReturnFileSetsFromDirectory";
        //    List<fileset> filesetsFound = new List<fileset>();

        //    try
        //    {
        //        if (!Directory.Exists(pathToSearch))
        //        {
        //            _Log.RecordMessage($"Directory not found: {pathToSearch}", BisLogMessageType.Warning, 1);
        //            return filesetsFound;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Log.RecordError($"Error checking directory existence: {pathToSearch}", ex, methodName);
        //        return filesetsFound;
        //    }

        //    if (!string.IsNullOrEmpty(icType) && !_GisTypeSettingRules.ContainsKey(icType))
        //    {
        //        _Log.RecordMessage("No IC Type provided for all filesets getting returned.", BisLogMessageType.Note);
        //    }

        //    if (searchSubFolders)
        //    {
        //        try
        //        {
        //            string[] subDirectories = Directory.GetDirectories(pathToSearch);
        //            foreach (string folder in subDirectories)
        //            {
        //                filesetsFound.AddRange(ReturnFileSetsFromDirectory_NewMethod(folder, icType, searchSubFolders));
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error processing subfolders in {pathToSearch}.", ex, methodName);
        //        }
        //    }

        //    Dictionary<string, List<string>> uniqueFileNamesInCurrentDir = ReturnUniqueFilenames(pathToSearch);
        //    Dictionary<string, string> renamedFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        //    List<string> filenamesToCheck = uniqueFileNamesInCurrentDir.Keys.ToList();

        //    foreach (string originalFileNameKey in filenamesToCheck)
        //    {
        //        if (originalFileNameKey.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;
        //        string cleanedFilename = originalFileNameKey.Replace("-", "_").Replace(".", "_").Replace("~", "_");

        //        if (originalFileNameKey != cleanedFilename)
        //        {
        //            if (uniqueFileNamesInCurrentDir.ContainsKey(cleanedFilename) && cleanedFilename != originalFileNameKey)
        //            {
        //                _Log.RecordMessage($"Target cleaned filename ({cleanedFilename}) already exists. Skipping rename of ({originalFileNameKey}) in '{pathToSearch}'.", BisLogMessageType.Warning, 2);
        //                continue;
        //            }
        //            _Log.RecordMessage($"File ({originalFileNameKey}) in path '{pathToSearch}' will be processed for renaming to ({cleanedFilename}).", BisLogMessageType.Note, 1);
        //            bool renameSuccessful = true;
        //            List<string> extensions = uniqueFileNamesInCurrentDir[originalFileNameKey];
        //            List<Tuple<string, string>> renameOperations = new List<Tuple<string, string>>();
        //            foreach (string ext in extensions)
        //            {
        //                string oldFullPath = Path.Combine(pathToSearch, originalFileNameKey + "." + ext);
        //                string newFullPath = Path.Combine(pathToSearch, cleanedFilename + "." + ext);
        //                renameOperations.Add(Tuple.Create(oldFullPath, newFullPath));
        //            }
        //            foreach (var op in renameOperations)
        //            {
        //                try
        //                {
        //                    File.Copy(op.Item1, op.Item2, true);
        //                    File.Delete(op.Item1);
        //                }
        //                catch (Exception ex)
        //                {
        //                    _Log.RecordError($"Error renaming file part '{op.Item1}' to '{op.Item2}'.", ex, methodName);
        //                    renameSuccessful = false;
        //                    break;
        //                }
        //            }
        //            if (renameSuccessful)
        //            {
        //                renamedFiles.Add(cleanedFilename, originalFileNameKey);
        //                uniqueFileNamesInCurrentDir.Add(cleanedFilename, extensions);
        //                uniqueFileNamesInCurrentDir.Remove(originalFileNameKey);
        //            }
        //            else
        //            {
        //                _Log.RecordMessage($"Rename failed for base file ({originalFileNameKey}) in '{pathToSearch}'. Original files might remain.", BisLogMessageType.Warning, 1);
        //            }
        //        }
        //    }

        //    List<string> fileTypeNamesToCheckFor = new List<string>();
        //    Dictionary<int, List<string>> filePriorities = new Dictionary<int, List<string>>();
        //    List<int> priorityValues = new List<int>();
        //    if (string.IsNullOrEmpty(icType))
        //    {
        //        foreach (FileSetRule fsr in _filesetRules.Values)
        //        {
        //            if (!fileTypeNamesToCheckFor.Contains(fsr.FilesetTypeName)) { fileTypeNamesToCheckFor.Add(fsr.FilesetTypeName); }
        //            ;
        //        }
        //    }
        //    else
        //    {
        //        List<AcceptedDatasetType> acceptedDataTypes = _GisTypeSettingRules[icType].AcceptedDatasets;
        //        foreach (AcceptedDatasetType adst in acceptedDataTypes)
        //        {
        //            fileTypeNamesToCheckFor.Add(adst.DatasetTypeName);
        //            int p = adst.Priority;
        //            if (!filePriorities.ContainsKey(p))
        //            {
        //                filePriorities.Add(p, new List<string>());
        //                priorityValues.Add(p);
        //            }
        //            filePriorities[p].Add(adst.DatasetTypeName);
        //            priorityValues.Sort();
        //        }
        //    }

        //    List<fileset> partialDataSetsFound = new List<fileset>();
        //    foreach (string filesetRuleName in fileTypeNamesToCheckFor.Distinct())
        //    {
        //        if (!_filesetRules.ContainsKey(filesetRuleName))
        //        {
        //            _Log.RecordMessage($"Unknown fileset type rule ({filesetRuleName}) requested for check in '{pathToSearch}'.", BisLogMessageType.Warning, 1);
        //            continue;
        //        }
        //        FileSetRule fileSetRule = _filesetRules[filesetRuleName];
        //        foreach (string baseFileName in uniqueFileNamesInCurrentDir.Keys)
        //        {
        //            if (baseFileName.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;
        //            List<string> requiredExtensionsFound = new List<string>();
        //            List<string> optionalExtensionsFound = new List<string>();

        //            foreach (string re in fileSetRule.RequiredExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Any(e => e.Equals(re, StringComparison.OrdinalIgnoreCase)))
        //                {
        //                    requiredExtensionsFound.Add(re);
        //                }
        //            }
        //            foreach (string oe in fileSetRule.OptionalExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Any(e => e.Equals(oe, StringComparison.OrdinalIgnoreCase)))
        //                {
        //                    optionalExtensionsFound.Add(oe);
        //                }
        //            }
        //            if (requiredExtensionsFound.Count > 0)
        //            {
        //                fileset fs = new fileset
        //                {
        //                    fileName = baseFileName,
        //                    path = pathToSearch,
        //                    filesetType = fileSetRule.FilesetTypeName,
        //                    extensions = new List<string>()
        //                };
        //                fs.extensions.AddRange(requiredExtensionsFound);
        //                fs.extensions.AddRange(optionalExtensionsFound);

        //                if (renamedFiles.TryGetValue(baseFileName, out string originalNameBeforeCleaning))
        //                {
        //                    fs.originalFileName = originalNameBeforeCleaning;
        //                }
        //                fs.validSet = (fileSetRule.RequiredExtensions.Count == requiredExtensionsFound.Count);
        //                filesetsFound.Add(fs);
        //                if (!string.IsNullOrEmpty(fileSetRule.SubsetOf)) { partialDataSetsFound.Add(fs); }
        //            }
        //        }
        //    }

        //    List<fileset> filesetsToBuildInCurrentDir = filesetsFound
        //        .Where(fs => !string.IsNullOrEmpty(_filesetRules[fs.filesetType].SubsetOf))
        //        .ToList();

        //    foreach (fileset fst in filesetsToBuildInCurrentDir)
        //    {
        //        string newFileNameForRepair = $"{fst.fileName}_toRepair";
        //        if (uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //        {
        //            _Log.RecordMessage($"File ({newFileNameForRepair}) already exists. Skipping copy/rename for subset ({fst.fileName}) type ({fst.filesetType}).", BisLogMessageType.Note, 2);
        //            continue;
        //        }
        //        try
        //        {
        //            bool copiedAtLeastOne = false;
        //            List<string> copiedExtensions = new List<string>();
        //            foreach (string ext in fst.extensions)
        //            {
        //                string sourceName = Path.Combine(fst.path, $"{fst.fileName}.{ext}");
        //                string destName = Path.Combine(fst.path, $"{newFileNameForRepair}.{ext}");
        //                File.Copy(sourceName, destName, true);
        //                copiedExtensions.Add(ext);
        //                copiedAtLeastOne = true;
        //            }
        //            if (copiedAtLeastOne)
        //            {
        //                int index = filesetsFound.FindIndex(existingFs => existingFs.fileName.Equals(fst.fileName, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.filesetType.Equals(fst.filesetType, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.path.Equals(fst.path, StringComparison.OrdinalIgnoreCase));
        //                if (index != -1)
        //                {
        //                    if (string.IsNullOrEmpty(filesetsFound[index].originalFileName))
        //                    {
        //                        filesetsFound[index].originalFileName = filesetsFound[index].fileName;
        //                    }
        //                    filesetsFound[index].fileName = newFileNameForRepair;
        //                    filesetsFound[index].extensions = copiedExtensions;
        //                    _Log.RecordMessage($"File ({fst.originalFileName ?? fst.fileName}) copied/renamed to ({newFileNameForRepair}) for type ({fst.filesetType}) to be rebuilt.", BisLogMessageType.Note, 2);

        //                    if (!uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //                    {
        //                        uniqueFileNamesInCurrentDir.Add(newFileNameForRepair, copiedExtensions);
        //                    }
        //                }
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error building copy of file {fst.fileName} for repair.", ex, methodName);
        //        }
        //    }

        //    if (filePriorities.Count > 0)
        //    {
        //        List<fileset> sortedFileSets = new List<fileset>();
        //        List<fileset> remainingFileSets = new List<fileset>(filesetsFound);
        //        foreach (int p in priorityValues)
        //        {
        //            if (filePriorities.TryGetValue(p, out List<string> typeListForPriority))
        //            {
        //                var foundForPriority = remainingFileSets
        //                    .Where(fs => typeListForPriority.Any(t => t.Equals(fs.filesetType, StringComparison.OrdinalIgnoreCase)))
        //                    .ToList();
        //                sortedFileSets.AddRange(foundForPriority);
        //                remainingFileSets.RemoveAll(fs => foundForPriority.Contains(fs));
        //            }
        //        }
        //        sortedFileSets.AddRange(remainingFileSets);
        //        return sortedFileSets.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                             .Select(g => g.First())
        //                             .ToList();
        //    }

        //    return filesetsFound.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                      .Select(g => g.First())
        //                      .ToList();
        //}




        //public List<fileset> ReturnFileSetsFromDirectory_yetagain(string pathToSearch, string icType = "", bool searchSubFolders = false)
        //{
        //    string methodName = "ReturnFileSetsFromDirectory";
        //    List<fileset> filesetsFound = new List<fileset>();

        //    try
        //    {
        //        if (!Directory.Exists(pathToSearch))
        //        {
        //            _Log.RecordMessage($"Directory not found: {pathToSearch}", BisLogMessageType.Warning, 1);
        //            return filesetsFound;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Log.RecordError($"Error checking directory existence: {pathToSearch}", ex, methodName);
        //        return filesetsFound;
        //    }

        //    if (!string.IsNullOrEmpty(icType) && !_GisTypeSettingRules.ContainsKey(icType))
        //    {
        //        _Log.RecordMessage("No IC Type provided for all filesets getting returned.", BisLogMessageType.Note);
        //    }

        //    if (searchSubFolders)
        //    {
        //        try
        //        {
        //            string[] subDirectories = Directory.GetDirectories(pathToSearch);
        //            foreach (string folder in subDirectories)
        //            {
        //                filesetsFound.AddRange(ReturnFileSetsFromDirectory_NewMethod(folder, icType, searchSubFolders));
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error processing subfolders in {pathToSearch}.", ex, methodName);
        //        }
        //    }

        //    Dictionary<string, List<string>> uniqueFileNamesInCurrentDir = ReturnUniqueFilenames(pathToSearch);
        //    Dictionary<string, string> renamedFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        //    List<string> filenamesToCheck = uniqueFileNamesInCurrentDir.Keys.ToList();

        //    foreach (string originalFileNameKey in filenamesToCheck)
        //    {
        //        if (originalFileNameKey.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;
        //        string cleanedFilename = originalFileNameKey.Replace("-", "_").Replace(".", "_").Replace("~", "_");

        //        if (originalFileNameKey != cleanedFilename)
        //        {
        //            if (uniqueFileNamesInCurrentDir.ContainsKey(cleanedFilename) && cleanedFilename != originalFileNameKey)
        //            {
        //                _Log.RecordMessage($"Target cleaned filename ({cleanedFilename}) already exists. Skipping rename of ({originalFileNameKey}) in '{pathToSearch}'.", BisLogMessageType.Warning, 2);
        //                continue;
        //            }
        //            _Log.RecordMessage($"File ({originalFileNameKey}) in path '{pathToSearch}' will be processed for renaming to ({cleanedFilename}).", BisLogMessageType.Note, 1);
        //            bool renameSuccessful = true;
        //            List<string> extensions = uniqueFileNamesInCurrentDir[originalFileNameKey];
        //            List<Tuple<string, string>> renameOperations = new List<Tuple<string, string>>();
        //            foreach (string ext in extensions)
        //            {
        //                string oldFullPath = Path.Combine(pathToSearch, originalFileNameKey + "." + ext);
        //                string newFullPath = Path.Combine(pathToSearch, cleanedFilename + "." + ext);
        //                renameOperations.Add(Tuple.Create(oldFullPath, newFullPath));
        //            }
        //            foreach (var op in renameOperations)
        //            {
        //                try
        //                {
        //                    File.Copy(op.Item1, op.Item2, true);
        //                    File.Delete(op.Item1);
        //                }
        //                catch (Exception ex)
        //                {
        //                    _Log.RecordError($"Error renaming file part '{op.Item1}' to '{op.Item2}'.", ex, methodName);
        //                    renameSuccessful = false;
        //                    break;
        //                }
        //            }
        //            if (renameSuccessful)
        //            {
        //                renamedFiles.Add(cleanedFilename, originalFileNameKey);
        //                uniqueFileNamesInCurrentDir.Add(cleanedFilename, extensions);
        //                uniqueFileNamesInCurrentDir.Remove(originalFileNameKey);
        //            }
        //            else
        //            {
        //                _Log.RecordMessage($"Rename failed for base file ({originalFileNameKey}) in '{pathToSearch}'. Original files might remain.", BisLogMessageType.Warning, 1);
        //            }
        //        }
        //    }

        //    List<string> fileTypeNamesToCheckFor = new List<string>();
        //    Dictionary<int, List<string>> filePriorities = new Dictionary<int, List<string>>();
        //    List<int> priorityValues = new List<int>();
        //    if (string.IsNullOrEmpty(icType))
        //    {
        //        foreach (FileSetRule fsr in _filesetRules.Values)
        //        {
        //            if (!fileTypeNamesToCheckFor.Contains(fsr.FilesetTypeName)) { fileTypeNamesToCheckFor.Add(fsr.FilesetTypeName); }
        //            ;
        //        }
        //    }
        //    else
        //    {
        //        List<AcceptedDatasetType> acceptedDataTypes = _GisTypeSettingRules[icType].AcceptedDatasets;
        //        foreach (AcceptedDatasetType adst in acceptedDataTypes)
        //        {
        //            fileTypeNamesToCheckFor.Add(adst.DatasetTypeName);
        //            int p = adst.Priority;
        //            if (!filePriorities.ContainsKey(p))
        //            {
        //                filePriorities.Add(p, new List<string>());
        //                priorityValues.Add(p);
        //            }
        //            filePriorities[p].Add(adst.DatasetTypeName);
        //            priorityValues.Sort();
        //        }
        //    }

        //    List<fileset> partialDataSetsFound = new List<fileset>();
        //    foreach (string filesetRuleName in fileTypeNamesToCheckFor.Distinct())
        //    {
        //        if (!_filesetRules.ContainsKey(filesetRuleName))
        //        {
        //            _Log.RecordMessage($"Unknown fileset type rule ({filesetRuleName}) requested for check in '{pathToSearch}'.", BisLogMessageType.Warning, 1);
        //            continue;
        //        }
        //        FileSetRule fileSetRule = _filesetRules[filesetRuleName];
        //        foreach (string baseFileName in uniqueFileNamesInCurrentDir.Keys)
        //        {
        //            if (baseFileName.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;
        //            List<string> requiredExtensionsFound = new List<string>();
        //            List<string> optionalExtensionsFound = new List<string>();

        //            foreach (string re in fileSetRule.RequiredExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Any(e => e.Equals(re, StringComparison.OrdinalIgnoreCase)))
        //                {
        //                    requiredExtensionsFound.Add(re);
        //                }
        //            }
        //            foreach (string oe in fileSetRule.OptionalExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Any(e => e.Equals(oe, StringComparison.OrdinalIgnoreCase)))
        //                {
        //                    optionalExtensionsFound.Add(oe);
        //                }
        //            }
        //            if (requiredExtensionsFound.Count > 0)
        //            {
        //                fileset fs = new fileset
        //                {
        //                    fileName = baseFileName,
        //                    path = pathToSearch,
        //                    filesetType = fileSetRule.FilesetTypeName,
        //                    extensions = new List<string>()
        //                };
        //                fs.extensions.AddRange(requiredExtensionsFound);
        //                fs.extensions.AddRange(optionalExtensionsFound);

        //                if (renamedFiles.TryGetValue(baseFileName, out string originalNameBeforeCleaning))
        //                {
        //                    fs.originalFileName = originalNameBeforeCleaning;
        //                }
        //                fs.validSet = (fileSetRule.RequiredExtensions.Count == requiredExtensionsFound.Count);
        //                filesetsFound.Add(fs);
        //                if (!string.IsNullOrEmpty(fileSetRule.SubsetOf)) { partialDataSetsFound.Add(fs); }
        //            }
        //        }
        //    }

        //    // The rest of the logic for handling _toRepair files should remain.
        //    List<fileset> filesetsToBuildInCurrentDir = filesetsFound
        //       .Where(fs =>
        //           !string.IsNullOrEmpty(_filesetRules[fs.filesetType].SubsetOf) &&
        //           !filesetsFound.Any(parentFs =>
        //               parentFs.fileName.Equals(fs.fileName, StringComparison.OrdinalIgnoreCase) &&
        //               parentFs.validSet &&
        //               parentFs.filesetType.Equals(_filesetRules[fs.filesetType].SubsetOf, StringComparison.OrdinalIgnoreCase)
        //           )
        //       )
        //       .ToList();

        //    foreach (fileset fst in filesetsToBuildInCurrentDir)
        //    {
        //        string newFileNameForRepair = $"{fst.fileName}_toRepair";
        //        if (uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //        {
        //            _Log.RecordMessage($"File ({newFileNameForRepair}) already exists. Skipping copy/rename for subset ({fst.fileName}) type ({fst.filesetType}).", BisLogMessageType.Note, 2);
        //            continue;
        //        }
        //        try
        //        {
        //            bool copiedAtLeastOne = false;
        //            List<string> copiedExtensions = new List<string>();
        //            foreach (string ext in fst.extensions)
        //            {
        //                string sourceName = Path.Combine(fst.path, $"{fst.fileName}.{ext}");
        //                string destName = Path.Combine(fst.path, $"{newFileNameForRepair}.{ext}");
        //                File.Copy(sourceName, destName, true);
        //                copiedExtensions.Add(ext);
        //                copiedAtLeastOne = true;
        //            }
        //            if (copiedAtLeastOne)
        //            {
        //                int index = filesetsFound.FindIndex(existingFs => existingFs.fileName.Equals(fst.fileName, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.filesetType.Equals(fst.filesetType, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.path.Equals(fst.path, StringComparison.OrdinalIgnoreCase));
        //                if (index != -1)
        //                {
        //                    if (string.IsNullOrEmpty(filesetsFound[index].originalFileName))
        //                    {
        //                        filesetsFound[index].originalFileName = filesetsFound[index].fileName;
        //                    }
        //                    filesetsFound[index].fileName = newFileNameForRepair;
        //                    filesetsFound[index].extensions = copiedExtensions;
        //                    _Log.RecordMessage($"File ({fst.originalFileName ?? fst.fileName}) copied/renamed to ({newFileNameForRepair}) for type ({fst.filesetType}) to be rebuilt.", BisLogMessageType.Note, 2);

        //                    if (!uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //                    {
        //                        uniqueFileNamesInCurrentDir.Add(newFileNameForRepair, copiedExtensions);
        //                    }
        //                }
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error building copy of file {fst.fileName} for repair.", ex, methodName);
        //        }
        //    }

        //    if (filePriorities.Count > 0)
        //    {
        //        List<fileset> sortedFileSets = new List<fileset>();
        //        List<fileset> remainingFileSets = new List<fileset>(filesetsFound);
        //        foreach (int p in priorityValues)
        //        {
        //            if (filePriorities.TryGetValue(p, out List<string> typeListForPriority))
        //            {
        //                var foundForPriority = remainingFileSets
        //                    .Where(fs => typeListForPriority.Any(t => t.Equals(fs.filesetType, StringComparison.OrdinalIgnoreCase)))
        //                    .ToList();
        //                sortedFileSets.AddRange(foundForPriority);
        //                remainingFileSets.RemoveAll(fs => foundForPriority.Contains(fs));
        //            }
        //        }
        //        sortedFileSets.AddRange(remainingFileSets);
        //        return sortedFileSets.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                             .Select(g => g.First())
        //                             .ToList();
        //    }

        //    return filesetsFound.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                      .Select(g => g.First())
        //                      .ToList();
        //}

        //public List<fileset> ReturnFileSetsFromDirectory_old2
        //    (string pathToSearch, string icType = "", bool searchSubFolders = false)
        //{
        //    string methodName = "ReturnFileSetsFromDirectory";
        //    List<fileset> filesetsFound = new List<fileset>();

        //    try
        //    {
        //        if (!Directory.Exists(pathToSearch))
        //        {
        //            _Log.RecordMessage($"Directory not found: {pathToSearch}", BisLogMessageType.Warning, 1);
        //            return filesetsFound;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Log.RecordError($"Error checking directory existence: {pathToSearch}", ex, methodName);
        //        return filesetsFound;
        //    }

        //    if (!string.IsNullOrEmpty(icType) && !_GisTypeSettingRules.ContainsKey(icType))
        //    {
        //        _Log.RecordMessage("No IC Type provided for all filesets getting returned.", BisLogMessageType.Note);
        //    }

        //    if (searchSubFolders)
        //    {
        //        try
        //        {
        //            string[] subDirectories = Directory.GetDirectories(pathToSearch);
        //            foreach (string folder in subDirectories)
        //            {
        //                filesetsFound.AddRange(ReturnFileSetsFromDirectory_NewMethod(folder, icType, searchSubFolders));
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error processing subfolders in {pathToSearch}.", ex, methodName);
        //        }
        //    }

        //    Dictionary<string, List<string>> uniqueFileNamesInCurrentDir = ReturnUniqueFilenames(pathToSearch);
        //    Dictionary<string, string> renamedFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        //    List<string> filenamesToCheck = uniqueFileNamesInCurrentDir.Keys.ToList();

        //    foreach (string originalFileNameKey in filenamesToCheck)
        //    {
        //        if (originalFileNameKey.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;
        //        string cleanedFilename = originalFileNameKey.Replace("-", "_").Replace(".", "_").Replace("~", "_");

        //        if (originalFileNameKey != cleanedFilename)
        //        {
        //            if (uniqueFileNamesInCurrentDir.ContainsKey(cleanedFilename) && cleanedFilename != originalFileNameKey)
        //            {
        //                _Log.RecordMessage($"Target cleaned filename ({cleanedFilename}) already exists. Skipping rename of ({originalFileNameKey}) in '{pathToSearch}'.", BisLogMessageType.Warning, 2);
        //                continue;
        //            }
        //            _Log.RecordMessage($"File ({originalFileNameKey}) in path '{pathToSearch}' will be processed for renaming to ({cleanedFilename}).", BisLogMessageType.Note, 1);
        //            bool renameSuccessful = true;
        //            List<string> extensions = uniqueFileNamesInCurrentDir[originalFileNameKey];
        //            List<Tuple<string, string>> renameOperations = new List<Tuple<string, string>>();
        //            foreach (string ext in extensions)
        //            {
        //                string oldFullPath = Path.Combine(pathToSearch, originalFileNameKey + "." + ext);
        //                string newFullPath = Path.Combine(pathToSearch, cleanedFilename + "." + ext);
        //                renameOperations.Add(Tuple.Create(oldFullPath, newFullPath));
        //            }
        //            foreach (var op in renameOperations)
        //            {
        //                try
        //                {
        //                    File.Copy(op.Item1, op.Item2, true);
        //                    File.Delete(op.Item1);
        //                }
        //                catch (Exception ex)
        //                {
        //                    _Log.RecordError($"Error renaming file part '{op.Item1}' to '{op.Item2}'.", ex, methodName);
        //                    renameSuccessful = false;
        //                    break;
        //                }
        //            }
        //            if (renameSuccessful)
        //            {
        //                renamedFiles.Add(cleanedFilename, originalFileNameKey);
        //                uniqueFileNamesInCurrentDir.Add(cleanedFilename, extensions);
        //                uniqueFileNamesInCurrentDir.Remove(originalFileNameKey);
        //            }
        //            else
        //            {
        //                _Log.RecordMessage($"Rename failed for base file ({originalFileNameKey}) in '{pathToSearch}'. Original files might remain.", BisLogMessageType.Warning, 1);
        //            }
        //        }
        //    }

        //    List<string> fileTypeNamesToCheckFor = new List<string>();
        //    Dictionary<int, List<string>> filePriorities = new Dictionary<int, List<string>>();
        //    List<int> priorityValues = new List<int>();
        //    if (string.IsNullOrEmpty(icType))
        //    {
        //        foreach (FileSetRule fsr in _filesetRules.Values)
        //        {
        //            if (!fileTypeNamesToCheckFor.Contains(fsr.FilesetTypeName)) { fileTypeNamesToCheckFor.Add(fsr.FilesetTypeName); }
        //            ;
        //        }
        //    }
        //    else
        //    {
        //        List<AcceptedDatasetType> acceptedDataTypes = _GisTypeSettingRules[icType].AcceptedDatasets;
        //        foreach (AcceptedDatasetType adst in acceptedDataTypes)
        //        {
        //            fileTypeNamesToCheckFor.Add(adst.DatasetTypeName);
        //            int p = adst.Priority;
        //            if (!filePriorities.ContainsKey(p))
        //            {
        //                filePriorities.Add(p, new List<string>());
        //                priorityValues.Add(p);
        //            }
        //            filePriorities[p].Add(adst.DatasetTypeName);
        //            priorityValues.Sort();
        //        }
        //    }

        //    List<fileset> partialDataSetsFound = new List<fileset>();
        //    foreach (string filesetRuleName in fileTypeNamesToCheckFor.Distinct())
        //    {
        //        if (!_filesetRules.ContainsKey(filesetRuleName))
        //        {
        //            _Log.RecordMessage($"Unknown fileset type rule ({filesetRuleName}) requested for check in '{pathToSearch}'.", BisLogMessageType.Warning, 1);
        //            continue;
        //        }
        //        FileSetRule fileSetRule = _filesetRules[filesetRuleName];
        //        foreach (string baseFileName in uniqueFileNamesInCurrentDir.Keys)
        //        {
        //            if (baseFileName.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;
        //            List<string> requiredExtensionsFound = new List<string>();
        //            List<string> optionalExtensionsFound = new List<string>();

        //            // --- START OF CORRECTED LOGIC ---
        //            foreach (string re in fileSetRule.RequiredExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Any(e => e.Equals(re, StringComparison.OrdinalIgnoreCase)))
        //                {
        //                    requiredExtensionsFound.Add(re);
        //                }
        //            }
        //            foreach (string oe in fileSetRule.OptionalExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Any(e => e.Equals(oe, StringComparison.OrdinalIgnoreCase)))
        //                {
        //                    optionalExtensionsFound.Add(oe);
        //                }
        //            }
        //            // --- END OF CORRECTED LOGIC ---

        //            if (requiredExtensionsFound.Count > 0)
        //            {
        //                fileset fs = new fileset
        //                {
        //                    fileName = baseFileName,
        //                    path = pathToSearch,
        //                    filesetType = fileSetRule.FilesetTypeName,
        //                    extensions = new List<string>()
        //                };
        //                fs.extensions.AddRange(requiredExtensionsFound);
        //                fs.extensions.AddRange(optionalExtensionsFound);

        //                if (renamedFiles.TryGetValue(baseFileName, out string originalNameBeforeCleaning))
        //                {
        //                    fs.originalFileName = originalNameBeforeCleaning;
        //                }
        //                fs.validSet = (fileSetRule.RequiredExtensions.Count == requiredExtensionsFound.Count);
        //                filesetsFound.Add(fs);
        //                if (!string.IsNullOrEmpty(fileSetRule.SubsetOf)) { partialDataSetsFound.Add(fs); }
        //            }
        //        }
        //    }

        //    List<fileset> filesetsToBuildInCurrentDir = filesetsFound
        //        .Where(fs => !string.IsNullOrEmpty(_filesetRules[fs.filesetType].SubsetOf))
        //        .ToList();

        //    foreach (fileset fst in filesetsToBuildInCurrentDir)
        //    {
        //        string newFileNameForRepair = $"{fst.fileName}_toRepair";
        //        if (uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //        {
        //            _Log.RecordMessage($"File ({newFileNameForRepair}) already exists. Skipping copy/rename for subset ({fst.fileName}) type ({fst.filesetType}).", BisLogMessageType.Note, 2);
        //            continue;
        //        }
        //        try
        //        {
        //            bool copiedAtLeastOne = false;
        //            List<string> copiedExtensions = new List<string>();
        //            foreach (string ext in fst.extensions)
        //            {
        //                string sourceName = Path.Combine(fst.path, $"{fst.fileName}.{ext}");
        //                string destName = Path.Combine(fst.path, $"{newFileNameForRepair}.{ext}");
        //                File.Copy(sourceName, destName, true);
        //                copiedExtensions.Add(ext);
        //                copiedAtLeastOne = true;
        //            }
        //            if (copiedAtLeastOne)
        //            {
        //                int index = filesetsFound.FindIndex(existingFs => existingFs.fileName.Equals(fst.fileName, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.filesetType.Equals(fst.filesetType, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.path.Equals(fst.path, StringComparison.OrdinalIgnoreCase));
        //                if (index != -1)
        //                {
        //                    if (string.IsNullOrEmpty(filesetsFound[index].originalFileName))
        //                    {
        //                        filesetsFound[index].originalFileName = filesetsFound[index].fileName;
        //                    }
        //                    filesetsFound[index].fileName = newFileNameForRepair;
        //                    filesetsFound[index].extensions = copiedExtensions;
        //                    _Log.RecordMessage($"File ({fst.originalFileName ?? fst.fileName}) copied/renamed to ({newFileNameForRepair}) for type ({fst.filesetType}) to be rebuilt.", BisLogMessageType.Note, 2);

        //                    if (!uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //                    {
        //                        uniqueFileNamesInCurrentDir.Add(newFileNameForRepair, copiedExtensions);
        //                    }
        //                }
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error building copy of file {fst.fileName} for repair.", ex, methodName);
        //        }
        //    }

        //    //var repairFilesets = filesetsFound
        //    //    .Where(fs => fs.fileName.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase) && !string.IsNullOrEmpty(fs.originalFileName))
        //    //    .ToList();
        //    //if (repairFilesets.Any())
        //    //{
        //    //    var originalNamesToRemove = repairFilesets.Select(fs => fs.originalFileName).Distinct(StringComparer.OrdinalIgnoreCase).ToList();
        //    //    int removedCount = filesetsFound.RemoveAll(fs =>
        //    //        originalNamesToRemove.Any(n => n.Equals(fs.fileName, StringComparison.OrdinalIgnoreCase)));
        //    //    if (removedCount > 0)
        //    //    {
        //    //        _Log.RecordMessage($"Corrected rules engine error: Removed {removedCount} incorrect duplicate fileset object(s).", BisLogMessageType.Note);
        //    //    }
        //    //}

        //    if (filePriorities.Count > 0)
        //    {
        //        List<fileset> sortedFileSets = new List<fileset>();
        //        List<fileset> remainingFileSets = new List<fileset>(filesetsFound);
        //        foreach (int p in priorityValues)
        //        {
        //            if (filePriorities.TryGetValue(p, out List<string> typeListForPriority))
        //            {
        //                // --- START OF CORRECTED LOGIC ---
        //                var foundForPriority = remainingFileSets
        //                    .Where(fs => typeListForPriority.Any(t => t.Equals(fs.filesetType, StringComparison.OrdinalIgnoreCase)))
        //                    .ToList();
        //                // --- END OF CORRECTED LOGIC ---
        //                sortedFileSets.AddRange(foundForPriority);
        //                remainingFileSets.RemoveAll(fs => foundForPriority.Contains(fs));
        //            }
        //        }
        //        sortedFileSets.AddRange(remainingFileSets);
        //        return sortedFileSets.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                             .Select(g => g.First())
        //                             .ToList();
        //    }

        //    return filesetsFound.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                      .Select(g => g.First())
        //                      .ToList();
        //}

        //public List<fileset> ReturnFileSetsFromDirectory_old(string pathToSearch, string icType = "", bool searchSubFolders = false)
        //{
        //    string methodName = "ReturnFileSetsFromDirectory";
        //    List<fileset> filesetsFound = new List<fileset>(); // Initialize here, this will be the accumulator for the current level and below.

        //    // Use try-catch for directory operations which can fail due to permissions etc.
        //    try
        //    {
        //        if (!Directory.Exists(pathToSearch))
        //        {
        //            _Log.RecordMessage($"Directory not found: {pathToSearch}", BisLogMessageType.Warning, 1);
        //            return filesetsFound; // Return empty list
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Log.RecordError($"Error checking directory existence: {pathToSearch}", ex, methodName);
        //        return filesetsFound; // Cannot proceed if directory check fails
        //    }


        //    if (!string.IsNullOrEmpty(icType) && !_GisTypeSettingRules.ContainsKey(icType))
        //    {
        //        //throw new Exception($"Unknown IC Type ({icType}).");
        //        _Log.RecordMessage("No IC Type provided for all filesets getting returned.", BisLogMessageType.Note);
        //    }

        //    // Recursive call for subfolders
        //    if (searchSubFolders)
        //    {
        //        try
        //        {
        //            // Get directories safely
        //            string[] subDirectories = Directory.GetDirectories(pathToSearch);
        //            foreach (string folder in subDirectories)
        //            {
        //                // The returned list from the recursive call contains filesets from that sub-branch.
        //                filesetsFound.AddRange(ReturnFileSetsFromDirectory_NewMethod(folder, icType, searchSubFolders));
        //            }
        //        }
        //        catch (UnauthorizedAccessException uae)
        //        {
        //            _Log.RecordError($"Access denied to a subfolder in {pathToSearch}.", uae, methodName);
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error processing subfolders in {pathToSearch}.", ex, methodName);
        //            // Depending on policy, you might want to rethrow or continue
        //        }
        //    }

        //    Dictionary<string, List<string>> uniqueFileNamesInCurrentDir;

        //    uniqueFileNamesInCurrentDir = ReturnUniqueFilenames(pathToSearch);


        //    // --- File Renaming Logic ---
        //    Dictionary<string, string> renamedFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        //    List<string> filenamesToCheck = uniqueFileNamesInCurrentDir.Keys.ToList(); // Process a copy of keys

        //    foreach (string originalFileNameKey in filenamesToCheck)
        //    {
        //        // Skip if the key itself contains "_toRepair" suffix, assuming these are intermediate files
        //        if (originalFileNameKey.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;

        //        string cleanedFilename = originalFileNameKey;
        //        // Simple replacement logic, consider more robust regex or char-by-char check if needed
        //        cleanedFilename = cleanedFilename.Replace("-", "_").Replace(".", "_").Replace("~", "_");

        //        if (originalFileNameKey != cleanedFilename) //the original filename contained an illegal character and needs to be renamed
        //        {
        //            // Check if cleanedFilename already exists (could be from a previous rename or an original file)
        //            if (uniqueFileNamesInCurrentDir.ContainsKey(cleanedFilename) && cleanedFilename != originalFileNameKey)
        //            {
        //                _Log.RecordMessage($"Target cleaned filename ({cleanedFilename}) already exists. Skipping rename of ({originalFileNameKey}) in '{pathToSearch}'.", BisLogMessageType.Warning, 2);
        //                continue; // Skip this rename
        //            }

        //            _Log.RecordMessage($"File ({originalFileNameKey}) in path '{pathToSearch}' will be processed for renaming to ({cleanedFilename}).", BisLogMessageType.Note, 1);
        //            bool renameSuccessful = true; // Flag to track success across all extensions

        //            List<string> extensions = uniqueFileNamesInCurrentDir[originalFileNameKey];
        //            // Attempt to rename all parts first 
        //            List<Tuple<string, string>> renameOperations = new List<Tuple<string, string>>();
        //            foreach (string ext in extensions)
        //            {
        //                string oldFullPath = Path.Combine(pathToSearch, originalFileNameKey + "." + ext);
        //                string newBaseFilenameWithExt = cleanedFilename + "." + ext;
        //                string newFullPath = Path.Combine(pathToSearch, newBaseFilenameWithExt);
        //                renameOperations.Add(Tuple.Create(oldFullPath, newFullPath));
        //            }

        //            // Execute renames
        //            foreach (var op in renameOperations)
        //            {
        //                try
        //                {
        //                    File.Copy(op.Item1, op.Item2, true);
        //                    File.Delete(op.Item1);
        //                }
        //                catch (Exception ex)
        //                {
        //                    _Log.RecordError($"Error renaming file part '{op.Item1}' to '{op.Item2}'.", ex, methodName);
        //                    renameSuccessful = false;
        //                    // Consider rollback or cleanup for already renamed parts if needed
        //                    break; // Stop renaming parts for this base name on first error
        //                }
        //            }

        //            if (renameSuccessful)
        //            {
        //                renamedFiles.Add(cleanedFilename, originalFileNameKey); // Track original name
        //                                                                        // Update uniqueFileNamesInCurrentDir to reflect the rename
        //                uniqueFileNamesInCurrentDir.Add(cleanedFilename, extensions);
        //                uniqueFileNamesInCurrentDir.Remove(originalFileNameKey);
        //                _Log.RecordMessage($"Successfully processed rename of ({originalFileNameKey}) to ({cleanedFilename}) in '{pathToSearch}'.", BisLogMessageType.Note, 1);
        //            }
        //            else
        //            {
        //                // If rename failed, don't update uniqueFileNamesInCurrentDir or renamedFiles map
        //                _Log.RecordMessage($"Rename failed for base file ({originalFileNameKey}) in '{pathToSearch}'. Original files might remain.", BisLogMessageType.Warning, 1);
        //            }

        //        }
        //    }

        //    // At this point the files in this directory have had their names checked and renamed if necessary 

        //    // --- fileset Identification Logic ---
        //    List<string> fileTypeNamesToCheckFor = new List<string>();
        //    Dictionary<int, List<string>> filePriorities = new Dictionary<int, List<string>>();
        //    List<int> priorityValues = new List<int>();
        //    //First build a list of IC types to search for
        //    if (string.IsNullOrEmpty(icType)) // no specific IC type was specified so search for any known type
        //    {
        //        foreach (FileSetRule fsr in _filesetRules.Values)
        //        {
        //            if (!fileTypeNamesToCheckFor.Contains(fsr.FilesetTypeName)) { fileTypeNamesToCheckFor.Add(fsr.FilesetTypeName); }
        //            ;
        //        }
        //    }
        //    else
        //    {
        //        List<AcceptedDatasetType> acceptedDataTypes = _GisTypeSettingRules[icType].AcceptedDatasets;
        //        foreach (AcceptedDatasetType adst in acceptedDataTypes)
        //        {
        //            fileTypeNamesToCheckFor.Add(adst.DatasetTypeName);
        //            int p = adst.Priority;
        //            if (!filePriorities.ContainsKey(p))
        //            {
        //                filePriorities.Add(p, new List<string>());
        //                priorityValues.Add(p);
        //            }
        //            filePriorities[p].Add(adst.DatasetTypeName);
        //            priorityValues.Sort(); // AI has the sort inside the loop?
        //        }
        //    }
        //    // filesets to look for are set now search for these types


        //    List<fileset> partialDataSetsFound = new List<fileset>();
        //    foreach (string filesetRuleName in fileTypeNamesToCheckFor.Distinct()) // Ensure unique rule names
        //    {
        //        if (!_filesetRules.ContainsKey(filesetRuleName))
        //        {
        //            _Log.RecordMessage($"Unknown fileset type rule ({filesetRuleName}) requested for check in '{pathToSearch}'.", BisLogMessageType.Warning, 1);
        //            continue;
        //        }

        //        FileSetRule fileSetRule = _filesetRules[filesetRuleName];

        //        foreach (string baseFileName in uniqueFileNamesInCurrentDir.Keys)
        //        {
        //            // Skip files marked for repair in this identification step
        //            if (baseFileName.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase)) continue;
        //            List<string> requiredExtensionsFound = new List<string>();
        //            List<string> optionalExtensionsFound = new List<string>();

        //            // This performs a case-insensitive check for the required extensions.
        //            foreach (string re in fileSetRule.RequiredExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Contains(re, StringComparer.OrdinalIgnoreCase))
        //                {
        //                    requiredExtensionsFound.Add(re);
        //                }
        //            }
        //            // This performs a case-insensitive check for the optional extensions.
        //            foreach (string oe in fileSetRule.OptionalExtensions)
        //            {
        //                if (uniqueFileNamesInCurrentDir[baseFileName].Contains(oe, StringComparer.OrdinalIgnoreCase))
        //                {
        //                    optionalExtensionsFound.Add(oe);
        //                }
        //            }


        //            // VB: If requiredExtensionsFound.Count > 0 Then
        //            if (requiredExtensionsFound.Count > 0)
        //            {
        //                fileset fs = new fileset
        //                {
        //                    fileName = baseFileName,
        //                    path = pathToSearch,
        //                    filesetType = fileSetRule.FilesetTypeName,
        //                    extensions = new List<string>()
        //                };
        //                fs.extensions.AddRange(requiredExtensionsFound);
        //                fs.extensions.AddRange(optionalExtensionsFound);
        //                // fs.extensions = fs.extensions.Distinct(StringComparer.OrdinalIgnoreCase).ToList();

        //                // record the original filename if it was renamed
        //                if (renamedFiles.TryGetValue(baseFileName, out string originalNameBeforeCleaning))
        //                {
        //                    fs.originalFileName = originalNameBeforeCleaning;
        //                }

        //                // A fileset is valid if ALL required extensions are found
        //                // fs.validSet = fileSetRule.RequiredExtensions.All(reqExt => requiredExtensionsFound.Contains(reqExt, StringComparer.OrdinalIgnoreCase))
        //                //             && fileSetRule.RequiredExtensions.Count == requiredExtensionsFound.Count; // Ensure all required are present

        //                // A fileset is valid only if the count of found required extensions matches the total number of required extensions.
        //                fs.validSet = (fileSetRule.RequiredExtensions.Count == requiredExtensionsFound.Count);

        //                filesetsFound.Add(fs);
        //                if (!string.IsNullOrEmpty(fileSetRule.SubsetOf)) { partialDataSetsFound.Add(fs); }
        //            }
        //        }
        //    }


        //    //// Identify partial datasets to remove if complete patent fileset is present (mainly shp files)
        //    //List <fileset> fileSetsToPullFromCurrentDir = new List<fileset>();
        //    //foreach (fileset partialDataset in partialDataSetsFound)
        //    //{
        //    //    foreach (fileset fst in filesetsFound)
        //    //    {
        //    //        string parentFilesetSubsetType = _filesetRules[partialDataset.filesetType].SubsetOf;
        //    //        if (filesetsFound.Any(foundFs => foundFs.fileName.Equals(partialDataset.fileName, StringComparison.OrdinalIgnoreCase) && foundFs.validSet && foundFs.filesetType.Equals(parentFilesetSubsetType, StringComparison.OrdinalIgnoreCase)))
        //    //        {
        //    //            fileSetsToPullFromCurrentDir.Add(partialDataset);
        //    //        }
        //    //    }
        //    // }

        //    //// Remove the identified partial datasets
        //    //filesetsFound.RemoveAll(fs => fileSetsToPullFromCurrentDir.Any(toPull =>
        //    //    toPull.fileName.Equals(fs.fileName, StringComparison.OrdinalIgnoreCase) &&
        //    //    toPull.filesetType.Equals(fs.filesetType, StringComparison.OrdinalIgnoreCase) &&
        //    //    toPull.path.Equals(fs.path, StringComparison.OrdinalIgnoreCase)
        //    //));    

        //    // Identify subsets that need the "_toRepair" suffix because their valid parent was NOT found
        //    List<fileset> filesetsToBuildInCurrentDir = filesetsFound
        //        .Where(fs => !string.IsNullOrEmpty(_filesetRules[fs.filesetType].SubsetOf))
        //        .ToList();

        //    foreach (fileset fst in filesetsToBuildInCurrentDir)
        //    {
        //        string newFileNameForRepair = $"{fst.fileName}_toRepair";
        //        // Check if a file with the _toRepair name already exists to avoid errors/duplicates
        //        if (uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //        {
        //            _Log.RecordMessage($"File ({newFileNameForRepair}) already exists. Skipping copy/rename for subset ({fst.fileName}) type ({fst.filesetType}).", BisLogMessageType.Note, 2);
        //            continue;
        //        }

        //        try
        //        {
        //            bool copiedAtLeastOne = false;
        //            List<string> copiedExtensions = new List<string>();
        //            foreach (string ext in fst.extensions)
        //            {
        //                string sourceName = Path.Combine(fst.path, $"{fst.fileName}.{ext}");
        //                string destName = Path.Combine(fst.path, $"{newFileNameForRepair}.{ext}");

        //                //Console.WriteLine($"MOCK: Would copy for repair '{sourceName}' to '{destName}'");
        //                File.Copy(sourceName, destName, true); // true to overwrite
        //                copiedExtensions.Add(ext);
        //                copiedAtLeastOne = true;
        //            }

        //            if (copiedAtLeastOne)
        //            {
        //                // Update the fileset entry in currentDirFilesets to reflect the rename
        //                int index = filesetsFound.FindIndex(existingFs => existingFs.fileName.Equals(fst.fileName, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.filesetType.Equals(fst.filesetType, StringComparison.OrdinalIgnoreCase) &&
        //                                                                existingFs.path.Equals(fst.path, StringComparison.OrdinalIgnoreCase));
        //                if (index != -1)
        //                {
        //                    // Keep original name if it wasn't already set (e.g., if it wasn't cleaned initially)
        //                    if (string.IsNullOrEmpty(filesetsFound[index].originalFileName))
        //                    {
        //                        filesetsFound[index].originalFileName = filesetsFound[index].fileName;
        //                    }
        //                    filesetsFound[index].fileName = newFileNameForRepair;
        //                    // Update the extensions list to only those that were successfully copied (important if copy fails mid-way)
        //                    filesetsFound[index].extensions = copiedExtensions;
        //                    _Log.RecordMessage($"File ({fst.originalFileName ?? fst.fileName}) copied/renamed to ({newFileNameForRepair}) for type ({fst.filesetType}) to be rebuilt.", BisLogMessageType.Note, 2);

        //                    // Add the new _toRepair entry to uniqueFileNamesInCurrentDir for consistency in the current scope
        //                    if (!uniqueFileNamesInCurrentDir.ContainsKey(newFileNameForRepair))
        //                    {
        //                        uniqueFileNamesInCurrentDir.Add(newFileNameForRepair, copiedExtensions);
        //                    }
        //                }
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            _Log.RecordError($"Error building copy of file {fst.fileName} for repair.", ex, methodName);
        //            // Potentially rethrow or handle
        //        }
        //    }

        //    /// filesetsFound.AddRange(filesetsFound); // AI added this, I don't think it is needed???      Add processed filesets from current directory to the main list

        //    // for incomplete shapefiles both a _toRepair and a shapefile reference were being returned. Adding this to filter out the shp reference

        //    // 1. Find all filesets that were marked for repair (i.e., renamed to end with "_toRepair").
        //    //var repairFilesets = filesetsFound
        //    //    .Where(fs => fs.fileName.EndsWith("_toRepair", StringComparison.OrdinalIgnoreCase) && !string.IsNullOrEmpty(fs.originalFileName))
        //    //    .ToList();

        //    //if (repairFilesets.Any())
        //    //{
        //    //    // 2. For each repair fileset, get its original name.
        //    //    var originalNamesToRemove = repairFilesets.Select(fs => fs.originalFileName).Distinct(StringComparer.OrdinalIgnoreCase).ToList();

        //    //    // 3. Remove any fileset from the main list whose filename matches one of the original names.
        //    //    int removedCount = filesetsFound.RemoveAll(fs =>
        //    //        originalNamesToRemove.Contains(fs.fileName, StringComparer.OrdinalIgnoreCase));

        //    //    if (removedCount > 0)
        //    //    {
        //    //        _Log.RecordMessage($"Corrected rules engine error: Removed {removedCount} incorrect duplicate fileset object(s).", BisLogMessageType.Note);
        //    //    }
        //    //}


        //    // Final sorting if priorities are involved
        //    if (filePriorities.Count > 0)
        //    {
        //        List<fileset> sortedFileSets = new List<fileset>();
        //        List<fileset> remainingFileSets = new List<fileset>(filesetsFound); // Copy to modify

        //        foreach (int p in priorityValues) // priorityValues is already sorted
        //        {
        //            if (filePriorities.TryGetValue(p, out List<string> typeListForPriority))
        //            {
        //                // Find filesets matching the current priority level
        //                var foundForPriority = remainingFileSets
        //                    .Where(fs => typeListForPriority.Contains(fs.filesetType, StringComparer.OrdinalIgnoreCase))
        //                    .ToList();

        //                sortedFileSets.AddRange(foundForPriority);

        //                // Remove found items from remaining list to avoid duplicates
        //                remainingFileSets.RemoveAll(fs => foundForPriority.Contains(fs));
        //            }
        //        }
        //        // Add any remaining filesets (those not matching any priority rule for the icType)
        //        sortedFileSets.AddRange(remainingFileSets);

        //        // Use a more robust distinct check based on path, filename, and type
        //        return sortedFileSets.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                             .Select(g => g.First())
        //                             .ToList();
        //    }

        //    // Return distinct filesets if no specific icType priorities
        //    return filesetsFound.GroupBy(fs => new { Path = fs.path.ToLowerInvariant(), FileName = fs.fileName.ToLowerInvariant(), Type = fs.filesetType.ToLowerInvariant() })
        //                      .Select(g => g.First())
        //                      .ToList();
        //}

        private List<IcFeatureField> ReturnFeatureFieldsForIcType(string icType)
        {
            string methodName = nameof(ReturnFeatureFieldsForIcType);
            List<IcFeatureField> returnVal = new List<IcFeatureField>();
            string qryName = "FeatureFieldsForIcType";
            DataTable dt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>();

            if (string.IsNullOrWhiteSpace(icType))
            {
                _Log.RecordError("icType cannot be null or whitespace in ReturnFeatureFieldsForIcType.", new ArgumentNullException(nameof(icType)), methodName);
                return returnVal; // Return empty list
            }

            paramDict.Add("IC_TYPE", icType.ToUpperInvariant());

  
                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);
 

            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for icType '{icType}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return returnVal; // Return empty list
            }

            if (dt.Rows.Count == 0)
            {
                // Original VB code commented out throwing an exception here, so just returning empty list.
                // _Log.recordError($"No field rules found for IC Type ({icType}). Query: {qryName}", new DataException("No rows returned for feature field rules."), methodName);
                return returnVal;
            }

            foreach (DataRow dr in dt.Rows)
            {
                IcFeatureField fieldRule = new IcFeatureField();

                // Safely get char and convert to string for comparison, then to bool
                string requiredCharStr = dr.GetStringValue("required");
                fieldRule.Required = requiredCharStr.Equals("Y", StringComparison.OrdinalIgnoreCase);

                string displayInPreviewStr = dr.GetStringValue("display_in_preview");
                fieldRule.DisplayInPreview = displayInPreviewStr.Equals("Y", StringComparison.OrdinalIgnoreCase);

                fieldRule.Fieldname = dr.GetStringValue("fieldname");
                fieldRule.MaxLength = dr.GetShortValue("max_size"); 

                returnVal.Add(fieldRule);
            }
            return returnVal;
        }

        //private Dictionary<string, string> ReturnFeatureFiltersForIcType(string icType)
        //{
        //    string methodName = nameof(ReturnFeatureFiltersForIcType);
        //    string qryName = "FeatureFiltersForIcType";
        //    DataTable dt = null;
        //    Dictionary<string, object> paramDict = new Dictionary<string, object>();

        //    if (string.IsNullOrWhiteSpace(icType))
        //    {
        //        _Log.RecordError("icType cannot be null or whitespace in ReturnFeatureFiltersForIcType.", new ArgumentNullException(nameof(icType)), methodName);
        //        return new Dictionary<string, string>(); // Return empty dictionary
        //    }

        //    paramDict.Add("subType", icType.ToUpperInvariant());

        //        dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


        //    if (dt == null)
        //    {
        //        _Log.RecordError($"Query '{qryName}' for icType '{icType}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
        //        return new Dictionary<string, string>(); // Return empty dictionary
        //    }

        //    // Group individual filter strings by fieldname
        //    var tempDict = new Dictionary<string, List<string>>();
        //    foreach (DataRow dr in dt.Rows)
        //    {
        //        string curFieldName = GetStringValue(dr, "fieldname");
        //        string curPattern = GetStringValue(dr, "filtervalue");

        //        if (string.IsNullOrEmpty(curFieldName)) continue; // Skip if fieldname is empty

        //        string comparitor = curPattern.Contains("%") ? "LIKE" : "=";
        //        // Ensure proper SQL string formatting: field names often don't need quotes unless they are reserved words or contain special chars.
        //        // String literals in SQL are enclosed in single quotes.
        //        // Escaping single quotes within the pattern if necessary (e.g., O'Malley -> O''Malley)
        //        string escapedPattern = curPattern.Replace("'", "''");
        //        string filterStr = $"(UPPER(\"{curFieldName}\") {comparitor} UPPER('{escapedPattern}'))"; // Assuming field names might need quoting

        //        if (tempDict.TryGetValue(curFieldName, out List<string> currentFilters))
        //        {
        //            currentFilters.Add(filterStr);
        //        }
        //        else
        //        {
        //            tempDict.Add(curFieldName, new List<string> { filterStr });
        //        }
        //    }

        //    // Collapse the grouped filter strings for each field into a single string joined by "OR"
        //    var returnDict = new Dictionary<string, string>();
        //    foreach (KeyValuePair<string, List<string>> kvp in tempDict)
        //    {
        //        if (kvp.Value.Any()) // Ensure there are filters to join
        //        {
        //            returnDict.Add(kvp.Key, $" ({string.Join(" OR ", kvp.Value)}) ");
        //        }
        //    }

        //    return returnDict;
        //}

        private Dictionary<string, List<string>> ReturnFeatureFiltersForIcType(string icType)
        {
            string methodName = nameof(ReturnFeatureFiltersForIcType);
            var returnDict = new Dictionary<string, List<string>>();
            string qryName = "FeatureFiltersForIcType";
            DataTable dt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>();

            if (string.IsNullOrWhiteSpace(icType))
            {
                _Log.RecordError("icType cannot be null or whitespace in ReturnFeatureFiltersForIcType.", new ArgumentNullException(nameof(icType)), methodName);
                return returnDict;
            }

            paramDict.Add("subType", icType.ToUpperInvariant());

            dt = (DataTable)_PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for icType '{icType}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return returnDict; // Return empty dictionary
            }
                   
            foreach (DataRow dr in dt.Rows)
            {
                string curFieldName = dr.GetStringValue("fieldname").ToUpper();
                string curPattern = dr.GetStringValue("filtervalue").ToUpper();

                if (string.IsNullOrEmpty(curFieldName)) continue; // Skip if fieldname is empty

                if (!returnDict.ContainsKey(curFieldName))
                {
                    returnDict[curFieldName] = new List<string>();
                };

                if (!returnDict[curFieldName].Contains(curPattern))
                {
                    returnDict[curFieldName].Add(curPattern);
                }
            }          
            return returnDict;
        }

        private GeometryRules ReturnGeometryRulesForIcType(string icType)
        {
            string methodName = nameof(ReturnGeometryRulesForIcType);
            GeometryRules returnVal = new GeometryRules(); // Initialize with default values

            string qryName = "GeometryRulesForIcType";
            DataTable dt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>();

            if (string.IsNullOrWhiteSpace(icType))
            {
                _Log.RecordError("icType cannot be null or whitespace in ReturnGeometryRulesForIcType.", new ArgumentNullException(nameof(icType)), methodName);
                return returnVal; // Return default/empty rules
            }

            paramDict.Add("IC_TYPE", icType.ToUpperInvariant());


                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for icType '{icType}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return returnVal; // Return default/empty rules
            }

            if (dt.Rows.Count == 0)
            {
                _Log.RecordError($"No geometry rules found for icType '{icType}' using query '{qryName}'. Returning default rules.", new DataException("No rows returned for geometry rules."), methodName);
                return returnVal; // Return default/empty rules if no data found
            }

            DataRow firstRow = dt.Rows[0]; // Assuming only one row of rules per icType

            // Using helper methods for safe conversion and C# PascalCase property names
            returnVal.X_Max = firstRow.GetDoubleValue("x_max");
            returnVal.X_Min = firstRow.GetDoubleValue("x_min");
            returnVal.Y_Max = firstRow.GetDoubleValue("y_max");
            returnVal.Y_Min = firstRow.GetDoubleValue("y_min"); 
            returnVal.Area_Tolerance = firstRow.GetDoubleValue("area_tolerance");
            returnVal.Linear_Tolerance = firstRow.GetDoubleValue("linear_tolerance");
            returnVal.Min_Area = firstRow.GetDoubleValue("min_area");
            returnVal.SiteDistance = firstRow.GetDoubleValue("sitedistance");
            returnVal.ProjectionId = firstRow.GetShortValue("projection_id");

            return returnVal;
        }


        private OutlookFolderSet ReturnOutlookFoldersetForIc(string icName)
        {
            string methodName = nameof(ReturnOutlookFoldersetForIc);
            string qryName = "RETURN_IC_OUTLOOK_FOLDERSET";
            Dictionary<string, object> paramDict = new Dictionary<string, object>();
            DataTable dt = null;
            OutlookFolderSet folderSet = new OutlookFolderSet();

            if (string.IsNullOrWhiteSpace(icName))
            {
                _Log.RecordError("icName cannot be null or whitespace in ReturnOutlookFoldersetForIc.", new ArgumentNullException(nameof(icName)), methodName);
                // Return an empty or default OutlookFolderSet, or throw, depending on desired behavior
                return folderSet; // Returning initialized empty set
            }

            icName = icName.ToUpperInvariant(); // Consistent casing for dictionary key and potentially DB query
            paramDict.Add("IcType", icName);

                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for IcType '{icName}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return folderSet; // Return initialized empty set
            }

            try
            {
                foreach (DataRow dr in dt.Rows)
                {
                    string folderType = dr.GetStringValue("folder_type"); // Using existing helper
                    string folderName = dr.GetStringValue("foldername");

                    // Use ToUpperInvariant() for reliable case-insensitive comparison
                    switch (folderType.ToUpperInvariant())
                    {
                        case "CORRESPONDENCE":
                            folderSet.CorrespondenceFolderName = folderName;
                            break;
                        case "INBOX":
                            folderSet.InboxFolderName = folderName;
                            break;
                        case "JUNKEMAIL": // VB had "JunkEmail"
                            folderSet.SpamFolderName = folderName;
                            break;
                        case "PROCESSED":
                            folderSet.ProccessedFolderName = folderName; // Keeping original property name
                            break;
                        case "ROOT":
                            folderSet.RootFolderName = folderName;
                            break;
                            // Optional: Add a default case to log unknown folder types
                            // default:
                            //     CLog.RecordError($"Unknown folder_type '{folderType}' encountered for IcType '{icName}'.", new ArgumentOutOfRangeException(nameof(folderType)), methodName);
                            //     break;
                    }
                }
            }
            catch (Exception ex)
            {
                _Log.RecordError($"Error processing Outlook folder rules for IcType '{icName}'. Error: {ex.Message}", ex, methodName);
                throw; // Re-throw to allow LoadAllSettings to handle it or propagate further
            }

            return folderSet;
        }

        private List<AcceptedDatasetType> ReturnAcceptedFilesetTypesForIc(string icType)
        {
            string methodName = nameof(ReturnAcceptedFilesetTypesForIc);
            string qryName = "acceptedFilesetTypesForIcType";
            DataTable dt = null;
            Dictionary<string, object> paramDict = new Dictionary<string, object>();

            // Handle potential null or empty icType early
            if (string.IsNullOrWhiteSpace(icType))
            {
                _Log.RecordError("icType cannot be null or whitespace in ReturnAcceptedFilesetTypesForIc.", new ArgumentNullException(nameof(icType)), methodName);
                return new List<AcceptedDatasetType>(); // Return empty list
            }

            paramDict.Add("subType", icType.ToUpperInvariant());


                dt = (DataTable) _PostGreTool.ExecuteNamedQuery(qryName, paramDict);


            List<AcceptedDatasetType> returnVal = new List<AcceptedDatasetType>();

            if (dt == null)
            {
                _Log.RecordError($"Query '{qryName}' for icType '{icType}' returned a null DataTable.", new NullReferenceException("DataTable from query was null."), methodName);
                return returnVal; // Return empty list
            }

            foreach (DataRow dr in dt.Rows)
            {
                AcceptedDatasetType dst = new AcceptedDatasetType();
                dst.DatasetTypeName = dr.GetStringValue("fileset_type"); 
                dst.Priority =  dr.GetShortValue("priority");      
                returnVal.Add(dst);
            }
            return returnVal;
        }

        public FileSetRule ReturnFilesetRuleForExtension(string extension)
        {
            if (string.IsNullOrWhiteSpace(extension)) return null;

            // Find all rules that contain this extension, using a case-insensitive comparison.
            var matchingRules = _filesetRules.Values.Where(rule =>
                rule.RequiredExtensions.Any(e => e.Equals(extension, StringComparison.OrdinalIgnoreCase)) ||
                rule.OptionalExtensions.Any(e => e.Equals(extension, StringComparison.OrdinalIgnoreCase)))
                .ToList();

            if (!matchingRules.Any())
            {
                return null; // No rule found for this extension.
            }

            if (matchingRules.Count == 1)
            {
                return matchingRules.First(); // Only one match, so return it.
            }

            // If there are multiple matches, prioritize the one that is NOT a subset.
            // This ensures we get "SHAPEFILE" instead of "INCOMPLETESHAPEFILE".
            return matchingRules.FirstOrDefault(rule => string.IsNullOrEmpty(rule.SubsetOf)) ?? matchingRules.First();
        }

        //public OleDbType GetOracleDbTypeValue(DataRow dr, string columnName, OleDbType defaultValue = OleDbType.VarChar)
        //{
        //    if (dr == null || !dr.Table.Columns.Contains(columnName) || dr.IsNull(columnName))
        //    {
        //        return defaultValue;
        //    }
        //    if (Enum.TryParse(Convert.ToString(dr[columnName]), true, out OleDbType result)) // true for case-insensitive
        //    {
        //        return result;
        //    }
        //    // Handle if it's stored as an integer
        //    if (int.TryParse(Convert.ToString(dr[columnName]), out int intValue))
        //    {
        //        if (Enum.IsDefined(typeof(OleDbType), intValue))
        //        {
        //            return (OleDbType)intValue;
        //        }
        //    }
        //    return defaultValue;
        //}


        //public string GetStringValue(DataRow dr, string columnName)
        //{
        //    return dr.IsNull(columnName) ? string.Empty : Convert.ToString(dr[columnName]);
        //}

        //public int GetIntValue(DataRow dr, string columnName)
        //{
        //    return dr.IsNull(columnName) ? 0 : Convert.ToInt32(dr[columnName]);
        //}

        //public DateTime GetDateTimeValue(DataRow dr, string columnName)
        //{
        //    if (dr == null || !dr.Table.Columns.Contains(columnName) || dr.IsNull(columnName))
        //    {
        //        return DateTime.MinValue; // Or some other appropriate default for your logic
        //    }
        //    if (DateTime.TryParse(Convert.ToString(dr[columnName]), out DateTime result))
        //    {
        //        return result;
        //    }
        //    return DateTime.MinValue; // Default if parsing fails
        //}

        //public bool GetBooleanValue(DataRow dr, string columnName)
        //{
        //    if (dr.IsNull(columnName)) return false;
        //    object value = dr[columnName];
        //    if (value is bool b) return b; // If already bool (e.g. from DB)
        //    string stringValue = Convert.ToString(value).ToUpperInvariant();
        //    return stringValue == "Y" || stringValue == "TRUE" || stringValue == "1";
        //}

        //public double GetDoubleValue(DataRow dr, string columnName)
        //{
        //    // Helper to safely get double values, returning 0.0 if DBNull or column doesn't exist or not convertible.
        //    if (dr == null || !dr.Table.Columns.Contains(columnName) || dr.IsNull(columnName))
        //    {
        //        return 0.0;
        //    }
        //    if (double.TryParse(Convert.ToString(dr[columnName]), out double result))
        //    {
        //        return result;
        //    }
        //    return 0.0;
        //}

        //public short GetShortValue(DataRow dr, string columnName)
        //{
        //    // Helper to safely get short (Int16) values, returning 0 if DBNull or column doesn't exist or not convertible.
        //    if (dr == null || !dr.Table.Columns.Contains(columnName) || dr.IsNull(columnName))
        //    {
        //        return 0;
        //    }
        //    if (short.TryParse(Convert.ToString(dr[columnName]), out short result))
        //    {
        //        return result;
        //    }
        //    return 0;
        //}
    }
}

####FILE: IcNamedTests.cs
using BIS_Tools_DataModels_2025;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text.RegularExpressions;
using static BIS_Log;
using static IC_Rules_2025.IcTestResult;

namespace IC_Rules_2025
{
    public class IcNamedTests
    {
        private string _ReportingClassName = "IcNamedTests";
        private BIS_Log _Log;
        private BIS_DB_PostGre _postGreTool;
        private Bis_Regex _regex_tool;
        private Dictionary<string, EmailTemplate> _emailTemplates = new Dictionary<string, EmailTemplate>();
        private Dictionary<string, IcTestRule> _NamedTests = new Dictionary<string, IcTestRule>();



        //public struct emailTemplate
        //{
        //    public string templateName;
        //    public string replacementText;
        //    public List<string> parameters;
        //    public string note;
        //    public string use;
        //}

        //private struct postscriptText
        //{
        //    public string text;
        //    public Int16 order;
        //}

        //public struct IcTestRule
        //{
        //    public String Name;
        //    public String Scope;
        //    public String Subtype;
        //    public TestActionResponse Action;
        //    public String EmailSRPGIS;
        //    public String EmailRP;
        //    public bool PreviewEmail;
        //    public String ErrorComment;
        //    public emailTemplate BodyTemplate;
        //    public emailTemplate SubjectTemplate;
        //    public bool IncludeSubmittedFiles;
        //    public List<string> filesToAdd;
        //    public List<string> postscriptText;
        //    public emailTemplate FailMessgae;
        //    public emailTemplate PassMessage;
        //    public emailTemplate MoreIfoMessage;
        //    public emailTemplate FailSubject;
        //    public emailTemplate PassSubject;
        //    public emailTemplate MoreIfoSubject;
        //}


        public IcNamedTests(BIS_Log log, BIS_DB_PostGre postgreDB)
        {
            _Log = log;
            _postGreTool = postgreDB ?? new BIS_DB_PostGre(_Log);
            _regex_tool = new Bis_Regex(log);
            loadTemplates();
            loadTestTypes();
        }

        private void loadTemplates()
        {
            string methodName = "loadTemplates";
            string qryStr = "Select * FROM SRP_REF_EMAIL_TEMPLATES";
            DataTable dt = (DataTable)_postGreTool.ExecuteRawQuery(qryStr);

            if (dt == null) throw new System.Exception($"Query {qryStr} failed.");

            _emailTemplates.Clear();
            foreach (DataRow dr in dt.Rows)
            {
                // Correctly read from the 'replacementtext' column
                string templateName = dr.GetStringValue("templateName");
                string replacementText = dr.GetStringValue("replacementtext");

                var newTemplate = new EmailTemplate
                {
                    TemplateName = templateName,
                    ReplacementText = replacementText,
                    Note = dr.GetStringValue("note"),
                    Use = dr.GetStringValue("use"),
                    Parameters = returnParameterNames(replacementText)
                };
                _emailTemplates.Add(templateName, newTemplate);
            }
        }

        private List<string> returnParameterNames(string textToSearch)
        {
            var parameterList = new List<string>();
            if (string.IsNullOrEmpty(textToSearch)) return parameterList;

            // Use the standard Regex class to find all matches
            var matches = Regex.Matches(textToSearch, @"\{\S+\}");
            foreach (Match match in matches)
            {
                string cleanParam = match.Value.Replace("{", "").Replace("}", "");
                if (!parameterList.Contains(cleanParam)) { parameterList.Add(cleanParam); }
            }
            return parameterList;
        }
               

        private void loadTestTypes()
        {
            string methodName = "loadTestTypes";
            string qryStr = "Select * FROM SRP_REF_ERROR_RULES WHERE SCOPE = 'GIS'";
            DataTable dt = (DataTable)_postGreTool.ExecuteRawQuery(qryStr);

            if (dt == null)
            {
                var ex = new Exception($"The query [{qryStr}] failed to execute properly.");
                _Log.RecordError("Nothing returned", ex, methodName);
                throw ex;
            }

            _NamedTests.Clear();
            try
            {
                foreach (DataRow dr in dt.Rows)
                {
                    string testName = dr.GetStringValue("error_name");
                    var newTest = new IcTestRule
                    {
                        Name = testName,
                        ErrorComment = dr.GetStringValue("error_comment"),
                        Scope = dr.GetStringValue("scope"),
                        Subtype = dr.GetStringValue("subtype"),
                    };

                    // Use the GetBooleanValue helper for all Y/N fields.
                    newTest.EmailHazsite = dr.GetNullableBooleanValue( "email_hazsite");
                    newTest.EmailRP = dr.GetNullableBooleanValue("email_rp");
                    newTest.PreviewEmail = dr.GetBooleanValue("previewemail");
                    newTest.IncludeSubmittedFiles = dr.GetNullableBooleanValue("includesubmittedfiles");
                    // --- END OF REFACTORED BOOLEAN LOGIC ---

                    string automatedaction = dr.GetStringValue("automated_action");
                    switch (automatedaction.ToUpper())
                    {
                        case "FAIL": newTest.Action = TestActionResponse.Fail; break;
                        case "MANUAL": newTest.Action = TestActionResponse.Manual; break;
                        case "NOTE": newTest.Action = TestActionResponse.Note; break;
                        case "WARN": newTest.Action = TestActionResponse.Warn; break;
                        case "SKIP": newTest.Action = TestActionResponse.Skip; break;
                        default: newTest.Action = TestActionResponse.None; break;
                    }

                    // Each template is now assigned to its own property.
                    string bodytemplatename = dr.GetStringValue("body_template");
                    string subjecttemplatename = dr.GetStringValue("subject_template"); 
                    string passedmessagetemplatename = dr.GetStringValue("passedtemplate");
                    string failedmessagetemplatename = dr.GetStringValue("failedtemplate");
                    string moreinfomessagetemplatename = dr.GetStringValue("moreinfotemplate");
                    string passedsubjecttemplatename = dr.GetStringValue("passedsubjecttemplate");
                    string failedsubjecttemplatename = dr.GetStringValue("failedsubjecttemplate");
                    string moreinfosubjecttemplatename = dr.GetStringValue("moreinfosubjecttemplate");

                    if (_emailTemplates.ContainsKey(bodytemplatename)) { newTest.BodyTemplate = _emailTemplates[bodytemplatename]; }
                    if (_emailTemplates.ContainsKey(subjecttemplatename)) { newTest.SubjectTemplate = _emailTemplates[subjecttemplatename]; }
                    if (_emailTemplates.ContainsKey(passedmessagetemplatename)) { newTest.PassMessage = _emailTemplates[passedmessagetemplatename]; }
                    if (_emailTemplates.ContainsKey(failedmessagetemplatename)) { newTest.FailMessage = _emailTemplates[failedmessagetemplatename]; }
                    if (_emailTemplates.ContainsKey(moreinfomessagetemplatename)) { newTest.MoreInfoMessage = _emailTemplates[moreinfomessagetemplatename]; }
                    if (_emailTemplates.ContainsKey(passedsubjecttemplatename)) { newTest.PassSubject = _emailTemplates[passedsubjecttemplatename]; }
                    if (_emailTemplates.ContainsKey(failedsubjecttemplatename)) { newTest.FailSubject = _emailTemplates[failedsubjecttemplatename]; }
                    if (_emailTemplates.ContainsKey(moreinfosubjecttemplatename)) { newTest.MoreInfoSubject = _emailTemplates[moreinfosubjecttemplatename]; }

                    //if (testName.Equals("GIS_Deliverable_Root", StringComparison.OrdinalIgnoreCase))
                    //{
                    //    _Log.RecordMessage("--- Debugging GIS_Deliverable_Root Rule ---", BisLogMessageType.Note);
                    //    string passedSubjectTemplateName = dr.GetStringValue("passedsubjecttemplate");
                    //    _Log.RecordMessage($"1. Name read from 'passedsubjecttemplate' column: '{passedSubjectTemplateName}'", BisLogMessageType.Note);

                    //    if (_emailTemplates.ContainsKey(passedSubjectTemplateName))
                    //    {
                    //        _Log.RecordMessage("2. SUCCESS: Found a matching key in the _emailTemplates dictionary.", BisLogMessageType.Note);
                    //        var template = _emailTemplates[passedSubjectTemplateName];
                    //        newTest.PassSubject = template;
                    //        _Log.RecordMessage($"3. Assigned Template. ReplacementText is: '{template.ReplacementText}'", BisLogMessageType.Note);
                    //    }
                    //    else
                    //    {
                    //        _Log.RecordError($"2. FAILED: Could not find key '{passedSubjectTemplateName}' in the _emailTemplates dictionary.", null, methodName);
                    //    }
                    //    _Log.RecordMessage("--- End of Debugging ---", BisLogMessageType.Note);
                    //}
                    //else
                    //{
                    //     passedsubjecttemplatename = dr.GetStringValue("passedsubjecttemplate");
                    //    if (_emailTemplates.ContainsKey(passedsubjecttemplatename)) { newTest.PassSubject = _emailTemplates[passedsubjecttemplatename]; }
                    //}





                    newTest.PostscriptText = returnPostscriptForTest(testName);
                    string additionalfiletoadd = dr.GetStringValue("additionalfiletoadd");
                    if (!string.IsNullOrEmpty(additionalfiletoadd)) { newTest.FilesToAdd = new List<string> { additionalfiletoadd }; }

                    _NamedTests.Add(testName.ToUpper(), newTest);
                }
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error building test rules.", ex, methodName);
                throw;
            }
        }

        //private void loadTestTypes()
        //{
        //    string methodName = "loadTestTypes";
        //    string qryStr = "Select * FROM SRP_REF_ERROR_RULES WHERE SCOPE = 'GIS'";
        //    DataTable dt = null;
        //    dt =(DataTable) _postGreTool.ExecuteRawQuery(qryStr);
        //    if (dt == null)
        //    {
        //        Exception ex = new Exception($"The query [{qryStr}] failed to execute properly.");
        //        _Log.RecordError("Nothing returned", ex, methodName);
        //        throw ex;
        //    }

        //    _NamedTests.Clear();
        //    try
        //    {
        //        foreach (DataRow dr in dt.Rows)
        //        {
        //            string testName = dr["error_name"].ToString();
        //            string errorcomment = dr["error_comment"].ToString();
        //            string automatedaction = dr["automated_action"].ToString();
        //            string scope = dr["scope"].ToString();
        //            string subtype = dr["subtype"].ToString();
        //            string emailsrpgis = dr["email_hazsite"].ToString();
        //            string emailrp = dr["email_rp"].ToString();
        //            string previewemail = dr["previewemail"].ToString();
        //            string bodytemplatename = dr["body_template"].ToString();
        //            string subjecttemplatename = dr["subject_template"].ToString();
        //            string passedmessagetemplatename = dr["passedtemplate"].ToString();
        //            string failedmessagetemplatename = dr["failedtemplate"].ToString();
        //            string moreinfomessagetemplatename = dr["moreinfotemplate"].ToString();
        //            string passedsubjecttemplatename = dr["passedsubjecttemplate"].ToString();
        //            string failedsubjecttemplatename = dr["failedsubjecttemplate"].ToString();
        //            string moreinfosubjecttemplatename = dr["moreinfosubjecttemplate"].ToString();
        //            string includesubmittedfiles = dr["includesubmittedfiles"].ToString();
        //            string additionalfiletoadd = dr["additionalfiletoadd"].ToString();

        //            IcTestRule newTest = new IcTestRule();
        //            switch (automatedaction.ToUpper())
        //            {
        //                case "FAIL":
        //                    newTest.Action = TestActionResponse.Fail;
        //                    break;
        //                case "MANUAL":
        //                    newTest.Action = TestActionResponse.Manual;
        //                    break;
        //                case "NOTE":
        //                    newTest.Action = TestActionResponse.Note;
        //                    break;
        //                case "WARN":
        //                    newTest.Action = TestActionResponse.Warn;
        //                    break;
        //                case "SKIP":
        //                    newTest.Action = TestActionResponse.Skip;
        //                    break;
        //                default:
        //                    newTest.Action = TestActionResponse.None;
        //                    break;
        //            }
        //            newTest.EmailSRPGIS = emailsrpgis.ToUpper();
        //            newTest.EmailRP = emailrp;
        //            newTest.PreviewEmail = (string)previewemail.ToUpper() == "Y";
        //            newTest.IncludeSubmittedFiles = (string)includesubmittedfiles.ToUpper() == "Y";
        //            newTest.ErrorComment = errorcomment;
        //            newTest.Scope = scope;
        //            newTest.Subtype = subtype;
        //            newTest.Name = testName;
        //            newTest.PostscriptText = returnPostscriptForTest(testName);
        //            if (!String.IsNullOrEmpty(additionalfiletoadd)) { newTest.FilesToAdd = new List<string> { additionalfiletoadd }; }
        //            if (_emailTemplates.ContainsKey(bodytemplatename)) { newTest.BodyTemplate = _emailTemplates[bodytemplatename]; }
        //            if (_emailTemplates.ContainsKey(subjecttemplatename)) { newTest.BodyTemplate = _emailTemplates[subjecttemplatename]; }
        //            if (_emailTemplates.ContainsKey(passedmessagetemplatename)) { newTest.BodyTemplate = _emailTemplates[passedmessagetemplatename]; }
        //            if (_emailTemplates.ContainsKey(failedmessagetemplatename)) { newTest.BodyTemplate = _emailTemplates[failedmessagetemplatename]; }
        //            if (_emailTemplates.ContainsKey(moreinfomessagetemplatename)) { newTest.BodyTemplate = _emailTemplates[moreinfomessagetemplatename]; }
        //            if (_emailTemplates.ContainsKey(passedsubjecttemplatename)) { newTest.BodyTemplate = _emailTemplates[passedsubjecttemplatename]; }
        //            if (_emailTemplates.ContainsKey(failedsubjecttemplatename)) { newTest.BodyTemplate = _emailTemplates[failedsubjecttemplatename]; }
        //            if (_emailTemplates.ContainsKey(moreinfosubjecttemplatename)) { newTest.BodyTemplate = _emailTemplates[moreinfosubjecttemplatename]; }
        //            _NamedTests.Add(testName.ToUpper(), newTest);
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _Log.RecordError("Error building test rules.", ex, methodName);
        //        throw;
        //    }
        //}

        public List<string> returnPostscriptForTest(object testname)
        {
            List<string> returnList = new List<string>();
            DataTable dt = null;
            string qryName = "returnPostscriptTextForRule";
            Dictionary<string, object> paramDict = new Dictionary<string, object>();
            paramDict.Add("ruleName", testname);
            dt = (DataTable)_postGreTool.ExecuteNamedQuery(qryName, paramDict);

            foreach (DataRow r in dt.Rows)
            {
                if (r["POSTTEXT"] != System.DBNull.Value) { returnList.Add((string)r["POSTTEXT"]); }
            }
            return returnList;
        }

        public Dictionary<string, string> returnCssStyleDefinitions()
        {
            DataTable dt = null;
            Dictionary<string, string> cssStyles = new Dictionary<string, string>();
                dt = (DataTable)_postGreTool.ExecuteNamedQuery("returnAllCssStyles");

            try
            {
                foreach (DataRow dr in dt.Rows)
                {
                    cssStyles.Add(dr["stylename"].ToString(), dr["stylecode"].ToString());
                }
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error building CSS Styles dictionary", ex, "returnCssStyleDefinitions");
                throw;
            }

            return cssStyles;
        }

        public string returnCssStyleDefinitionHtml()
        {
            Dictionary<string, string> cssStyles = new Dictionary<string, string>();

                cssStyles = returnCssStyleDefinitions();


            List<string> styleTextList = new List<string>();
            try
            {
                styleTextList.Add("<!-- Begin Named Styles -->");
                foreach (KeyValuePair<string, string> kvp in cssStyles)
                {
                    styleTextList.Add($"<style> .{kvp.Key} {"{"} {kvp.Value} {"}"} </style>");
                }
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error building CSS style definition HTML", ex, "returnCssStyleDefinitionHtml");
                throw;
            }
            return String.Join("\n", styleTextList.ToArray()) + "\n";
        }

        private List<string> removeMissingParameters(string textToFillIn, string emptyReplacementValue = "*Missing")
        {
            string methodName = "removeMissingParameters";
            List<string> missingParameterList = new List<string>();

                missingParameterList = returnParameterNames(textToFillIn);


            Dictionary<string, string> parameterDict = new Dictionary<string, string>();
            foreach (string p in missingParameterList)
            {
                parameterDict.Add(p, emptyReplacementValue);
            }

                fillInParameters(textToFillIn, parameterDict);

            return missingParameterList;
        }

        /// <summary>
        /// The main public method for filling in all parameters and sub-templates in a given string.
        /// </summary>
        /// <summary>
        /// The main public method for filling in all parameters and sub-templates in a given string.
        /// It now returns both the processed text and a list of any parameters that were found in the
        /// template but not provided in the parameters dictionary.
        /// </summary>
        public (string ProcessedText, List<string> MissingParameters) FillAllParameters(string textToUpdate, Dictionary<string, string> parameters)
        {
            if (string.IsNullOrEmpty(textToUpdate)) return ("", new List<string>());

            // First, recursively replace all the {Template_...} placeholders.
            string processedText = ReplaceSubTemplates(textToUpdate);

            // Find all potential value placeholders in the fully expanded text.
            var placeholdersInText = returnParameterNames(processedText)
                .Where(p => !p.StartsWith("Template_"))
                .ToList();

            // Now, fill in the placeholders we have values for.
            processedText = FillValueParameters(processedText, parameters);

            // Determine which parameters were in the text but not in our dictionary.
            var missingParams = placeholdersInText
                .Where(p => !parameters.ContainsKey(p))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            // Clean up any remaining (missing) placeholders from the text.
            processedText = Regex.Replace(processedText, @"\{\S+\}", "*Missing*");

            return (processedText, missingParams);
        }
        /// <summary>
        /// Returns a list of email templates that are specifically marked for use as inserts.
        /// </summary>
        public List<EmailTemplate> ReturnInsertTemplates()
        {
            // This assumes that your insertable templates have their 'use' column set to "StaticText_IC"
            return _emailTemplates.Values
                .Where(t => "StaticText_IC".Equals(t.Use, StringComparison.OrdinalIgnoreCase))
                .OrderBy(t => t.TemplateName)
                .ToList();
        }

        /// <summary>
        /// Recursively finds and replaces sub-template placeholders (e.g., {Template_GIS_Rejected}).
        /// </summary>
        //private string ReplaceSubTemplates(string text)
        //{
        //    var matches = _regex_tool.ReturnMatchesOfNamedRegex(@"\{Template_\S+\}", text);
        //    foreach (var match in matches)
        //    {
        //        string subTemplateName = match.Replace("{Template_", "").Replace("}", "");
        //        if (_emailTemplates.TryGetValue(subTemplateName, out var subTemplate))
        //        {
        //            // Recursively process the sub-template itself before replacing.
        //            string subTemplateText = ReplaceSubTemplates(subTemplate.ReplacementText);
        //            text = text.Replace(match, subTemplateText);
        //        }
        //    }
        //    return text;
        //}
        private string ReplaceSubTemplates(string text)
        {
            if (string.IsNullOrEmpty(text)) return "";
            // Use the standard .NET Regex class directly to find matches for our raw pattern.
            var matches = Regex.Matches(text, @"\{Template_\S+\}");

            for (int i = matches.Count - 1; i >= 0; i--)
            {
                var match = matches[i];
                string subTemplateName = match.Value.Replace("{Template_", "").Replace("}", "");
                if (_emailTemplates.TryGetValue(subTemplateName, out var subTemplate))
                {
                    string subTemplateText = ReplaceSubTemplates(subTemplate.ReplacementText);
                    text = text.Replace(match.Value, subTemplateText);
                }
            }
            return text;
        }


        /// <summary>
        /// Fills in the simple value placeholders (e.g., {DELID}, {PREFID}).
        /// </summary>
        private string FillValueParameters(string text, Dictionary<string, string> parameters)
        {
            if (parameters == null || string.IsNullOrEmpty(text)) return text ?? "";

            // Use a Regex for more robust, case-insensitive replacement
            foreach (var kvp in parameters)
            {
                string placeholderRegex = $"\\{{{Regex.Escape(kvp.Key)}\\}}";
                text = Regex.Replace(text, placeholderRegex, kvp.Value, RegexOptions.IgnoreCase);
            }
            return text;
        }


        public List<string> fillInParameters(string textToUpdate, Dictionary<string, string>? parameterDefinitions = null)
        {
            string methodName = "fillInParameters";
            if (parameterDefinitions == null) { parameterDefinitions = new Dictionary<string, string>(); };
            List<string> paramsInText = new List<string>();
            if (String.IsNullOrEmpty(textToUpdate)) { return paramsInText; }

                replaceSubtemplateParamaters(textToUpdate);


            List<string> missingParams = new List<string>();
            foreach (string param in paramsInText)
            {
                if (parameterDefinitions.ContainsKey(param) && !string.IsNullOrEmpty(parameterDefinitions[param]))
                {
                    string paramToReplace = "{" + param + "}";
                    textToUpdate = textToUpdate.Replace(paramToReplace, parameterDefinitions[param]);
                }
                else
                {
                    missingParams.Add(param);
                }
            }
            return missingParams;
        }

        public List<string> replaceSubtemplateParamaters(string textToUpdate, List<string>? paramListToReturn = null)
        {
            string methodName = "fillInParameters";
            if (paramListToReturn == null) { paramListToReturn = new List<string>(); };
            List<string> curTestParamList = new List<string>();
            if (string.IsNullOrWhiteSpace(textToUpdate)) { return curTestParamList; }
            // check the text for any parameters

                curTestParamList = returnParamaterNames(textToUpdate);


            // check these parameters for subtemplate paramters
            foreach (string param in curTestParamList)
            {
                if (param.StartsWith("Template_"))
                {
                    string subTemplateName = param.Substring(9);
                    EmailTemplate subTemplate = new EmailTemplate();
                    //grab subtemplate and extract parameters

                        subTemplate = returnEmailTemplate(subTemplateName);

                    //recursively replace any subTemplates in each subtemplate

                        paramListToReturn = replaceSubtemplateParamaters(subTemplate.ReplacementText, paramListToReturn);

                    // first body then subject line
                    textToUpdate = textToUpdate.Replace("{" + param + "}", subTemplate.ReplacementText);
                }
                else
                {
                    if (!paramListToReturn.Contains(param)) { paramListToReturn.Add(param); }
                };
            }
            return paramListToReturn;
        }


        private EmailTemplate returnEmailTemplate(string templateName)
        {
            string methodName = "returnEmailTemplate";
            if (String.IsNullOrWhiteSpace(templateName)) { throw new ArgumentNullException(nameof(templateName)); }
            if (_emailTemplates.Count == 0) 
            {
                Exception ex = new Exception("Named email templates do not appear to have been loaded propery.");
                _Log.RecordError("Failed to return email template.", ex, methodName);
                throw ex;
            };

            if (!_emailTemplates.ContainsKey(templateName))
            {
                Exception ex = new Exception($"No template name found by the name {templateName}");
                _Log.RecordError("Failed to return email template.", ex, methodName);
                throw ex;
            }

            EmailTemplate templateToReturn = new EmailTemplate();
            templateToReturn.ReplacementText = _emailTemplates[templateName].ReplacementText;
            templateToReturn.TemplateName = templateName;
            templateToReturn.Parameters = _emailTemplates[templateName].Parameters;
            templateToReturn.Note = _emailTemplates[templateName].Note;
            templateToReturn.Use = _emailTemplates[templateName].Use;
            return templateToReturn;
        }

        private List<string> returnParamaterNames(string textToSearch)
        {
            string methodName = "returnParamaterNames";
            List<String> parameterList = new List<string>();
            List<String> matchList = new List<String>();

            try
            {
                matchList = _regex_tool.ReturnMatchesOfNamedRegex(@"\{\S+\}", textToSearch);
            }
            catch (Exception ex)
            {
                _Log.RecordError("Error returning parameter names.", ex, methodName);
                throw;
            }

            try
            {
                foreach(string param in matchList)
                {
                    string cleanedParam = param.Replace("{","") ;
                    cleanedParam = cleanedParam.Replace("}", "");
                    if(!parameterList.Contains(param) ) { parameterList.Add(param) ; } 
                }
            }
            catch(Exception ex)
            {
                _Log.RecordError("Error building param list.", ex, methodName);
                throw;
            }
            return parameterList;        
        } 
        
        public void saveTemplate(string templateName, String replacementText, String note = "")
        {
            string methodName = "saveTemplate";
            if (String.IsNullOrEmpty(templateName)) { throw new ArgumentNullException(nameof(templateName));}
            if (String.IsNullOrEmpty(replacementText)) { throw new ArgumentNullException(nameof(replacementText)); }

            Dictionary<String,Object> ParamDict = new Dictionary<String,Object>();
            ParamDict.Add("replacementtext", replacementText);
            ParamDict.Add("note", note);
            ParamDict.Add("templatename", templateName);

            string qryName = "";
            if (_emailTemplates.ContainsKey(templateName))
            {
                qryName = "updateEmailTemplate";
            }
            else
            {
                qryName = "InsertNewEmailTemplate";
            }

                _postGreTool.ExecuteNamedQuery(qryName, ParamDict);


                loadTemplates();

        }

        public List<String> namedTemplates()
        {
            List<String> templateNames = _emailTemplates.Keys.ToList();
            templateNames.Sort();
            return templateNames;
        }

        public Dictionary<String,String> returnStaticTemplates()
        {
            Dictionary<String, String> returnVal = new Dictionary<String, String>();
            foreach(KeyValuePair<String,EmailTemplate> kvp in _emailTemplates)
            {
                if (kvp.Value.Use == "StaticText_IC") { returnVal.Add(kvp.Key, kvp.Value.ReplacementText); }
            }
            return returnVal;
        }

        public IcTestRule returnTestRule(string testName)
        {
            string methodName = "returnTestRule";
            if (String.IsNullOrEmpty(testName)) { throw new ArgumentNullException(nameof(testName)); }
            if (_NamedTests.Count == 0)
            {
                Exception ex = new Exception("Named IC tests do not appear to have been loaded propery.");
                _Log.RecordError("Failed to return test rule.", ex, methodName);
                throw ex;
            }

            if (!_NamedTests.ContainsKey(testName.ToUpper()))
            {
                Exception ex = new Exception($"No IC test found by the name ({testName}).");
                _Log.RecordError("Failed to return test rule.", ex, methodName);
                throw ex;
            }

            IcTestRule masterRule = _NamedTests[testName.ToUpper()];
            IcTestRule RuleToReturn = new IcTestRule
            {
                Action = masterRule.Action,
                ErrorComment = masterRule.ErrorComment,
                Name = masterRule.Name,
                Scope = masterRule.Scope,
                Subtype = masterRule.Subtype,
                PreviewEmail = masterRule.PreviewEmail,
                EmailRP = masterRule.EmailRP,
                EmailHazsite = masterRule.EmailHazsite,
                BodyTemplate = masterRule.BodyTemplate,
                IncludeSubmittedFiles = masterRule.IncludeSubmittedFiles,
                FilesToAdd = masterRule.FilesToAdd,
                PostscriptText = masterRule.PostscriptText,
                SubjectTemplate = masterRule.SubjectTemplate,
                PassMessage = masterRule.PassMessage,
                FailMessage = masterRule.FailMessage, 
                MoreInfoMessage = masterRule.MoreInfoMessage, 
                PassSubject = masterRule.PassSubject,
                FailSubject = masterRule.FailSubject,
                MoreInfoSubject = masterRule.MoreInfoSubject
            };
            return RuleToReturn;
        }

        public String returnTestResultIdForReferenceId(string refId, IcTestResult.TestType testType)
        {
            string methodName = "returnTestResultIdForReferenceId";
            string qryStr = "";

            switch (testType)
            {
                case TestType.Deliverable:
                    qryStr = String.Format($"SELECT SRP_GIS_DELIVERABLES.TESTRESULTID FROM SRP_GIS_DELIVERABLES WHERE SRP_GIS_DELIVERABLES.DELIVERABLE_ID = '{refId}'");
                    break;
                case TestType.Submission:
                    qryStr = String.Format($"SELECT SRP_GIS_SUBMISSION.TESTRESULTID FROM SRP_GIS_SUBMISSION WHERE SRP_SUBMISSION_EDD.SUBMISSION_ID ='{refId}'");
                    break;
                case TestType.Shape:
                    qryStr = String.Format("SELECT SRP_GIS_IC_SHAPE_INFO.TESTRESULTID FROM SRP_GIS_IC_SHAPE_INFO WHERE SRP_GIS_IC_SHAPE_INFO.SHAPE_ID = '{refId}'");
                    break;
                default:
                    throw new Exception("Unknown test type");
            }

            DataTable dt = new DataTable();


                dt =(DataTable) _postGreTool.ExecuteNamedQuery(qryStr);


            if(dt.Rows.Count == 0) { return ""; }


            if (!DBNull.Value.Equals(dt.Rows[0][0])){return (String)dt.Rows[0][0];}
            else { return String.Empty; }
        }

        public IcTestResult returnNewTestResult(string testName, string refId,TestType testType)
        {
            IcTestRule testRule = returnTestRule(testName);
            //IcTestResult tr = new IcTestResult(testRule, refId, testType, _Log, _postGreTool, this);
            IcTestResult tr = new IcTestResult(testRule, refId, testType, _Log, null, this); 
            return tr;
        }
    }
}

####FILE: IcTestResult.cs
using BIS_Tools_DataModels_2025;
using System;
using System.Collections.Generic;
using System.Linq;

namespace IC_Rules_2025
{
    public class IcTestResult
    {
        private readonly BIS_Log _log;
        private readonly BIS_DB_PostGre _postgreTool;
        private readonly IcNamedTests _namedTestsRepo;
        private bool _testPassed = true; // The private backing field for the Passed property

        public enum TestType { Deliverable, Submission, Shape }

        public struct CumulativeActions
        {
            public TestActionResponse ResultAction;
            public bool? EmailRp;
            public bool? EmailHazsite;
            public bool PreviewEmail;
            public bool IncludeSubmittedFiles;
        }

        #region Public Properties

        public string TestResultId { get; private set; }
        public IcTestRule TestRule { get; }
        public string RefId { get; set; }
        public TestType ResultType { get; }
        public List<string> Comments { get; } = new List<string>();
        public IReadOnlyList<IcTestResult> SubTestResults => _subTestResults.AsReadOnly();
        private readonly List<IcTestResult> _subTestResults = new List<IcTestResult>();
        public CumulativeActions CumulativeAction { get; private set; }
        public Dictionary<string, string> OutputParams { get; } = new Dictionary<string, string>();
        public TestActionResponse TestResultAction { get; private set; } = TestActionResponse.Pass;

        public bool Passed
        {
            get => _testPassed;
            set
            {
                _testPassed = value;
                // When the result of this specific test is set, update its individual action.
                TestResultAction = _testPassed ? TestActionResponse.Pass : TestRule.Action;
                // As you suggested, immediately recalculate the cumulative action for the entire tree.
                RecalculateCumulativeAction();
            }
        }

        #endregion

        public IcTestResult(IcTestRule icTest, string refId, TestType testType, BIS_Log log, BIS_DB_PostGre postGreTool, IcNamedTests namedTests)
        {
            _log = log ?? throw new ArgumentNullException(nameof(log));
            _postgreTool = postGreTool ?? new BIS_DB_PostGre(_log);
            _namedTestsRepo = namedTests ?? throw new ArgumentNullException(nameof(namedTests));
            TestRule = icTest ?? throw new ArgumentNullException(nameof(icTest));
            RefId = refId;
            ResultType = testType;
            // Initialize the cumulative action when the object is created.
            RecalculateCumulativeAction();
        }

        public void addParameter(string key, string value)
        {
            if (!string.IsNullOrWhiteSpace(key) && !string.IsNullOrWhiteSpace(value))
            {
                OutputParams[key.Trim()] = value.Trim();
            }
        }

        public void AddComment(string comment)
        {
            if (!string.IsNullOrWhiteSpace(comment))
            {
                Comments.Add(comment.Trim());
            }
        }

        public void AddSubordinateTestResult(IcTestResult subTest)
        {
            _subTestResults.Add(subTest);
            RecalculateCumulativeAction();
        }

        private void RecalculateCumulativeAction()
        {
            // Start with the most severe action being from this test itself.
            var mostSevereAction = this.TestResultAction;

            // Now, check if any child has a more severe action.
            foreach (var subResult in _subTestResults)
            {
                if (subResult.CumulativeAction.ResultAction > mostSevereAction)
                {
                    mostSevereAction = subResult.CumulativeAction.ResultAction;
                }
            }

            // Aggregate the boolean email flags from this test and all children.
            bool emailRp = this.TestRule.EmailRP ?? false;
            bool emailHazsite = this.TestRule.EmailHazsite ?? false;
            bool previewEmail = this.TestRule.PreviewEmail;
            bool includeFiles = this.TestRule.IncludeSubmittedFiles ?? false; ;

            foreach (var subResult in _subTestResults)
            {
                emailRp |= subResult.CumulativeAction.EmailRp ?? false;
                emailHazsite |= subResult.CumulativeAction.EmailHazsite ?? false;
                previewEmail |= subResult.CumulativeAction.PreviewEmail;
                includeFiles |= subResult.CumulativeAction.IncludeSubmittedFiles; 
            }

            // If the final, most severe action for this entire test tree is NOT a failure,
            // then we should NEVER include the submitted files, regardless of what any
            // sub-rule might have said.
            if (mostSevereAction != TestActionResponse.Fail)
            {
                includeFiles = false;
            }

            // Set the final cumulative action for this test result object.
            this.CumulativeAction = new CumulativeActions
            {
                ResultAction = mostSevereAction,
                EmailRp = emailRp,
                EmailHazsite = emailHazsite,
                PreviewEmail = previewEmail,
                 IncludeSubmittedFiles = includeFiles
            };
        }

        public string RecordResults(string masterResultId = "")
        {
            // If this is the root test, clear previous runs for this RefId.
            if (string.IsNullOrEmpty(masterResultId))
            {
                ClearLatestFlagForPreviousRuns();
            }

            var paramDict = new Dictionary<string, object>
            {
                {"OutputParams", string.Join("~~", OutputParams.Select(kvp => $"{kvp.Key}~{kvp.Value}")) },
                { "MasterResultId", string.IsNullOrEmpty(masterResultId) ? DBNull.Value : (object)masterResultId },
                { "TestType", this.ResultType.ToString() },
                { "RefId", this.RefId },
                { "TestName", this.TestRule.Name },
                { "testResult", this.Passed ? "Passed" : "Failed" },
                { "COMMENTS", string.Join("; ", this.Comments) }
            };

            // Record this test result and get its new ID
            this.TestResultId = _postgreTool.ExecuteNamedQuery("addIcTestResult", paramDict)?.ToString();

            // Recursively record all sub-test results, passing the new ID as their master ID
            foreach (var subResult in _subTestResults)
            {
                subResult.RecordResults(this.TestResultId);
            }

            // If this was the root test, update the main deliverable/submission table with this ID.
            if (string.IsNullOrEmpty(masterResultId))
            {
                UpdateMasterRecordWithTestId();
            }

            return this.TestResultId;
        }

        private void UpdateMasterRecordWithTestId()
        {
            string qryName;
            switch (this.ResultType)
            {
                case TestType.Deliverable: qryName = "recordIcDeliverableTestResultId"; break;
                case TestType.Submission: qryName = "recordIcSubmissionTestResultId"; break;
                case TestType.Shape: qryName = "recordIcShapeResultId"; break;
                default: return;
            }

            var paramDict = new Dictionary<string, object>
            {
                { "refId", this.RefId },
                { "testResultId", this.TestResultId }
            };
            _postgreTool.ExecuteNamedQuery(qryName, paramDict);
        }

        private void ClearLatestFlagForPreviousRuns()
        {
            var paramDict = new Dictionary<string, object>
            {
                { "refId", this.RefId },
                { "testtype", this.ResultType.ToString() }
            };
            _postgreTool.ExecuteNamedQuery("setPreviousICRunsToNotLatest", paramDict);
        }

        public void UpdateAllRefIds(string newRefId)
        {
            this.RefId = newRefId;
            foreach (var subResult in _subTestResults)
            {
                subResult.UpdateAllRefIds(newRefId);
            }
        }
    }
}